// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cp_comunication.proto

#ifndef PROTOBUF_cp_5fcomunication_2eproto__INCLUDED
#define PROTOBUF_cp_5fcomunication_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ctp {
namespace cp {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cp_5fcomunication_2eproto();
void protobuf_AssignDesc_cp_5fcomunication_2eproto();
void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

class Command;
class MQLevel;
class TradeResult;
class LoginStatus;
class Position;
class Account;
class BacktestingExpectAssetList;
class BacktestingExpectAssetQuery;
class BacktestingResultSave2DBRequery;
class BacktestingResultSave2DBRequery_BacktestingResultItem;
class BacktestingResultSave2DBResponse;
class test1;
class test2;

// ===================================================================

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // repeated string params = 2;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 2;
  inline const ::std::string& params(int index) const;
  inline ::std::string* mutable_params(int index);
  inline void set_params(int index, const ::std::string& value);
  inline void set_params(int index, const char* value);
  inline void set_params(int index, const char* value, size_t size);
  inline ::std::string* add_params();
  inline void add_params(const ::std::string& value);
  inline void add_params(const char* value);
  inline void add_params(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& params() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_params();

  // @@protoc_insertion_point(class_scope:ctp.cp.Command)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cmd_;
  ::google::protobuf::RepeatedPtrField< ::std::string> params_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class MQLevel : public ::google::protobuf::Message {
 public:
  MQLevel();
  virtual ~MQLevel();

  MQLevel(const MQLevel& from);

  inline MQLevel& operator=(const MQLevel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MQLevel& default_instance();

  void Swap(MQLevel* other);

  // implements Message ----------------------------------------------

  MQLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MQLevel& from);
  void MergeFrom(const MQLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required string utc_string = 3;
  inline bool has_utc_string() const;
  inline void clear_utc_string();
  static const int kUtcStringFieldNumber = 3;
  inline const ::std::string& utc_string() const;
  inline void set_utc_string(const ::std::string& value);
  inline void set_utc_string(const char* value);
  inline void set_utc_string(const char* value, size_t size);
  inline ::std::string* mutable_utc_string();
  inline ::std::string* release_utc_string();
  inline void set_allocated_utc_string(::std::string* utc_string);

  // required int64 utc = 4;
  inline bool has_utc() const;
  inline void clear_utc();
  static const int kUtcFieldNumber = 4;
  inline ::google::protobuf::int64 utc() const;
  inline void set_utc(::google::protobuf::int64 value);

  // required double open_price = 5;
  inline bool has_open_price() const;
  inline void clear_open_price();
  static const int kOpenPriceFieldNumber = 5;
  inline double open_price() const;
  inline void set_open_price(double value);

  // required double high_price = 6;
  inline bool has_high_price() const;
  inline void clear_high_price();
  static const int kHighPriceFieldNumber = 6;
  inline double high_price() const;
  inline void set_high_price(double value);

  // required double low_price = 7;
  inline bool has_low_price() const;
  inline void clear_low_price();
  static const int kLowPriceFieldNumber = 7;
  inline double low_price() const;
  inline void set_low_price(double value);

  // required double close_price = 8;
  inline bool has_close_price() const;
  inline void clear_close_price();
  static const int kClosePriceFieldNumber = 8;
  inline double close_price() const;
  inline void set_close_price(double value);

  // required int32 volumn = 9;
  inline bool has_volumn() const;
  inline void clear_volumn();
  static const int kVolumnFieldNumber = 9;
  inline ::google::protobuf::int32 volumn() const;
  inline void set_volumn(::google::protobuf::int32 value);

  // required int32 counter = 10;
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 10;
  inline ::google::protobuf::int32 counter() const;
  inline void set_counter(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ctp.cp.MQLevel)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_utc_string();
  inline void clear_has_utc_string();
  inline void set_has_utc();
  inline void clear_has_utc();
  inline void set_has_open_price();
  inline void clear_has_open_price();
  inline void set_has_high_price();
  inline void clear_has_high_price();
  inline void set_has_low_price();
  inline void clear_has_low_price();
  inline void set_has_close_price();
  inline void clear_has_close_price();
  inline void set_has_volumn();
  inline void clear_has_volumn();
  inline void set_has_counter();
  inline void clear_has_counter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  ::std::string* utc_string_;
  ::google::protobuf::int64 utc_;
  double open_price_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 volumn_;
  double high_price_;
  double low_price_;
  double close_price_;
  ::google::protobuf::int32 counter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static MQLevel* default_instance_;
};
// -------------------------------------------------------------------

class TradeResult : public ::google::protobuf::Message {
 public:
  TradeResult();
  virtual ~TradeResult();

  TradeResult(const TradeResult& from);

  inline TradeResult& operator=(const TradeResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeResult& default_instance();

  void Swap(TradeResult* other);

  // implements Message ----------------------------------------------

  TradeResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradeResult& from);
  void MergeFrom(const TradeResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string ms_name = 3;
  inline bool has_ms_name() const;
  inline void clear_ms_name();
  static const int kMsNameFieldNumber = 3;
  inline const ::std::string& ms_name() const;
  inline void set_ms_name(const ::std::string& value);
  inline void set_ms_name(const char* value);
  inline void set_ms_name(const char* value, size_t size);
  inline ::std::string* mutable_ms_name();
  inline ::std::string* release_ms_name();
  inline void set_allocated_ms_name(::std::string* ms_name);

  // required string os_name = 4;
  inline bool has_os_name() const;
  inline void clear_os_name();
  static const int kOsNameFieldNumber = 4;
  inline const ::std::string& os_name() const;
  inline void set_os_name(const ::std::string& value);
  inline void set_os_name(const char* value);
  inline void set_os_name(const char* value, size_t size);
  inline ::std::string* mutable_os_name();
  inline ::std::string* release_os_name();
  inline void set_allocated_os_name(::std::string* os_name);

  // required string ms_id = 5;
  inline bool has_ms_id() const;
  inline void clear_ms_id();
  static const int kMsIdFieldNumber = 5;
  inline const ::std::string& ms_id() const;
  inline void set_ms_id(const ::std::string& value);
  inline void set_ms_id(const char* value);
  inline void set_ms_id(const char* value, size_t size);
  inline ::std::string* mutable_ms_id();
  inline ::std::string* release_ms_id();
  inline void set_allocated_ms_id(::std::string* ms_id);

  // required string os_id = 6;
  inline bool has_os_id() const;
  inline void clear_os_id();
  static const int kOsIdFieldNumber = 6;
  inline const ::std::string& os_id() const;
  inline void set_os_id(const ::std::string& value);
  inline void set_os_id(const char* value);
  inline void set_os_id(const char* value, size_t size);
  inline ::std::string* mutable_os_id();
  inline ::std::string* release_os_id();
  inline void set_allocated_os_id(::std::string* os_id);

  // required int64 ms_time = 7;
  inline bool has_ms_time() const;
  inline void clear_ms_time();
  static const int kMsTimeFieldNumber = 7;
  inline ::google::protobuf::int64 ms_time() const;
  inline void set_ms_time(::google::protobuf::int64 value);

  // required double total_cash = 8;
  inline bool has_total_cash() const;
  inline void clear_total_cash();
  static const int kTotalCashFieldNumber = 8;
  inline double total_cash() const;
  inline void set_total_cash(double value);

  // required double average_price = 9;
  inline bool has_average_price() const;
  inline void clear_average_price();
  static const int kAveragePriceFieldNumber = 9;
  inline double average_price() const;
  inline void set_average_price(double value);

  // required double ms_price = 10;
  inline bool has_ms_price() const;
  inline void clear_ms_price();
  static const int kMsPriceFieldNumber = 10;
  inline double ms_price() const;
  inline void set_ms_price(double value);

  // required int32 total_volumn = 11;
  inline bool has_total_volumn() const;
  inline void clear_total_volumn();
  static const int kTotalVolumnFieldNumber = 11;
  inline ::google::protobuf::int32 total_volumn() const;
  inline void set_total_volumn(::google::protobuf::int32 value);

  // required int32 traded_volumn = 12;
  inline bool has_traded_volumn() const;
  inline void clear_traded_volumn();
  static const int kTradedVolumnFieldNumber = 12;
  inline ::google::protobuf::int32 traded_volumn() const;
  inline void set_traded_volumn(::google::protobuf::int32 value);

  // required int32 oc = 13;
  inline bool has_oc() const;
  inline void clear_oc();
  static const int kOcFieldNumber = 13;
  inline ::google::protobuf::int32 oc() const;
  inline void set_oc(::google::protobuf::int32 value);

  // required int32 bs = 14;
  inline bool has_bs() const;
  inline void clear_bs();
  static const int kBsFieldNumber = 14;
  inline ::google::protobuf::int32 bs() const;
  inline void set_bs(::google::protobuf::int32 value);

  // required int64 start_time = 15;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 15;
  inline ::google::protobuf::int64 start_time() const;
  inline void set_start_time(::google::protobuf::int64 value);

  // required int64 over_time = 16;
  inline bool has_over_time() const;
  inline void clear_over_time();
  static const int kOverTimeFieldNumber = 16;
  inline ::google::protobuf::int64 over_time() const;
  inline void set_over_time(::google::protobuf::int64 value);

  // required int64 cost_time = 17;
  inline bool has_cost_time() const;
  inline void clear_cost_time();
  static const int kCostTimeFieldNumber = 17;
  inline ::google::protobuf::int64 cost_time() const;
  inline void set_cost_time(::google::protobuf::int64 value);

  // required string last_error = 18;
  inline bool has_last_error() const;
  inline void clear_last_error();
  static const int kLastErrorFieldNumber = 18;
  inline const ::std::string& last_error() const;
  inline void set_last_error(const ::std::string& value);
  inline void set_last_error(const char* value);
  inline void set_last_error(const char* value, size_t size);
  inline ::std::string* mutable_last_error();
  inline ::std::string* release_last_error();
  inline void set_allocated_last_error(::std::string* last_error);

  // required int32 withdraw_times = 19;
  inline bool has_withdraw_times() const;
  inline void clear_withdraw_times();
  static const int kWithdrawTimesFieldNumber = 19;
  inline ::google::protobuf::int32 withdraw_times() const;
  inline void set_withdraw_times(::google::protobuf::int32 value);

  // required int32 level = 20;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 20;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ctp.cp.TradeResult)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ms_name();
  inline void clear_has_ms_name();
  inline void set_has_os_name();
  inline void clear_has_os_name();
  inline void set_has_ms_id();
  inline void clear_has_ms_id();
  inline void set_has_os_id();
  inline void clear_has_os_id();
  inline void set_has_ms_time();
  inline void clear_has_ms_time();
  inline void set_has_total_cash();
  inline void clear_has_total_cash();
  inline void set_has_average_price();
  inline void clear_has_average_price();
  inline void set_has_ms_price();
  inline void clear_has_ms_price();
  inline void set_has_total_volumn();
  inline void clear_has_total_volumn();
  inline void set_has_traded_volumn();
  inline void clear_has_traded_volumn();
  inline void set_has_oc();
  inline void clear_has_oc();
  inline void set_has_bs();
  inline void clear_has_bs();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_over_time();
  inline void clear_has_over_time();
  inline void set_has_cost_time();
  inline void clear_has_cost_time();
  inline void set_has_last_error();
  inline void clear_has_last_error();
  inline void set_has_withdraw_times();
  inline void clear_has_withdraw_times();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::std::string* type_;
  ::std::string* ms_name_;
  ::std::string* os_name_;
  ::std::string* ms_id_;
  ::std::string* os_id_;
  ::google::protobuf::int64 ms_time_;
  double total_cash_;
  double average_price_;
  double ms_price_;
  ::google::protobuf::int32 total_volumn_;
  ::google::protobuf::int32 traded_volumn_;
  ::google::protobuf::int32 oc_;
  ::google::protobuf::int32 bs_;
  ::google::protobuf::int64 start_time_;
  ::google::protobuf::int64 over_time_;
  ::google::protobuf::int64 cost_time_;
  ::std::string* last_error_;
  ::google::protobuf::int32 withdraw_times_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static TradeResult* default_instance_;
};
// -------------------------------------------------------------------

class LoginStatus : public ::google::protobuf::Message {
 public:
  LoginStatus();
  virtual ~LoginStatus();

  LoginStatus(const LoginStatus& from);

  inline LoginStatus& operator=(const LoginStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginStatus& default_instance();

  void Swap(LoginStatus* other);

  // implements Message ----------------------------------------------

  LoginStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginStatus& from);
  void MergeFrom(const LoginStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // required string time_string = 2;
  inline bool has_time_string() const;
  inline void clear_time_string();
  static const int kTimeStringFieldNumber = 2;
  inline const ::std::string& time_string() const;
  inline void set_time_string(const ::std::string& value);
  inline void set_time_string(const char* value);
  inline void set_time_string(const char* value, size_t size);
  inline ::std::string* mutable_time_string();
  inline ::std::string* release_time_string();
  inline void set_allocated_time_string(::std::string* time_string);

  // required string user = 3;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required int32 error_id = 4;
  inline bool has_error_id() const;
  inline void clear_error_id();
  static const int kErrorIdFieldNumber = 4;
  inline ::google::protobuf::int32 error_id() const;
  inline void set_error_id(::google::protobuf::int32 value);

  // required string error_msg = 5;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 5;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  inline void set_allocated_error_msg(::std::string* error_msg);

  // required string ip = 6;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 6;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:ctp.cp.LoginStatus)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_time_string();
  inline void clear_has_time_string();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_error_id();
  inline void clear_has_error_id();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* time_string_;
  ::std::string* user_;
  ::std::string* error_msg_;
  ::std::string* ip_;
  ::google::protobuf::int32 error_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static LoginStatus* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // required string time_string = 2;
  inline bool has_time_string() const;
  inline void clear_time_string();
  static const int kTimeStringFieldNumber = 2;
  inline const ::std::string& time_string() const;
  inline void set_time_string(const ::std::string& value);
  inline void set_time_string(const char* value);
  inline void set_time_string(const char* value, size_t size);
  inline ::std::string* mutable_time_string();
  inline ::std::string* release_time_string();
  inline void set_allocated_time_string(::std::string* time_string);

  // required string user = 3;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required double price_index = 4;
  inline bool has_price_index() const;
  inline void clear_price_index();
  static const int kPriceIndexFieldNumber = 4;
  inline double price_index() const;
  inline void set_price_index(double value);

  // required double stop_price = 5;
  inline bool has_stop_price() const;
  inline void clear_stop_price();
  static const int kStopPriceFieldNumber = 5;
  inline double stop_price() const;
  inline void set_stop_price(double value);

  // required string instrumentid = 6;
  inline bool has_instrumentid() const;
  inline void clear_instrumentid();
  static const int kInstrumentidFieldNumber = 6;
  inline const ::std::string& instrumentid() const;
  inline void set_instrumentid(const ::std::string& value);
  inline void set_instrumentid(const char* value);
  inline void set_instrumentid(const char* value, size_t size);
  inline ::std::string* mutable_instrumentid();
  inline ::std::string* release_instrumentid();
  inline void set_allocated_instrumentid(::std::string* instrumentid);

  // required string brokerid = 7;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokeridFieldNumber = 7;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  inline void set_allocated_brokerid(::std::string* brokerid);

  // required string investorid = 8;
  inline bool has_investorid() const;
  inline void clear_investorid();
  static const int kInvestoridFieldNumber = 8;
  inline const ::std::string& investorid() const;
  inline void set_investorid(const ::std::string& value);
  inline void set_investorid(const char* value);
  inline void set_investorid(const char* value, size_t size);
  inline ::std::string* mutable_investorid();
  inline ::std::string* release_investorid();
  inline void set_allocated_investorid(::std::string* investorid);

  // required int32 posidirection = 9;
  inline bool has_posidirection() const;
  inline void clear_posidirection();
  static const int kPosidirectionFieldNumber = 9;
  inline ::google::protobuf::int32 posidirection() const;
  inline void set_posidirection(::google::protobuf::int32 value);

  // required int32 hedgeflag = 10;
  inline bool has_hedgeflag() const;
  inline void clear_hedgeflag();
  static const int kHedgeflagFieldNumber = 10;
  inline ::google::protobuf::int32 hedgeflag() const;
  inline void set_hedgeflag(::google::protobuf::int32 value);

  // required int32 positiondate = 11;
  inline bool has_positiondate() const;
  inline void clear_positiondate();
  static const int kPositiondateFieldNumber = 11;
  inline ::google::protobuf::int32 positiondate() const;
  inline void set_positiondate(::google::protobuf::int32 value);

  // required int32 ydposition = 12;
  inline bool has_ydposition() const;
  inline void clear_ydposition();
  static const int kYdpositionFieldNumber = 12;
  inline ::google::protobuf::int32 ydposition() const;
  inline void set_ydposition(::google::protobuf::int32 value);

  // required int32 position = 13;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 13;
  inline ::google::protobuf::int32 position() const;
  inline void set_position(::google::protobuf::int32 value);

  // required int32 longfrozen = 14;
  inline bool has_longfrozen() const;
  inline void clear_longfrozen();
  static const int kLongfrozenFieldNumber = 14;
  inline ::google::protobuf::int32 longfrozen() const;
  inline void set_longfrozen(::google::protobuf::int32 value);

  // required int32 shortfrozen = 15;
  inline bool has_shortfrozen() const;
  inline void clear_shortfrozen();
  static const int kShortfrozenFieldNumber = 15;
  inline ::google::protobuf::int32 shortfrozen() const;
  inline void set_shortfrozen(::google::protobuf::int32 value);

  // required double longfrozenamount = 16;
  inline bool has_longfrozenamount() const;
  inline void clear_longfrozenamount();
  static const int kLongfrozenamountFieldNumber = 16;
  inline double longfrozenamount() const;
  inline void set_longfrozenamount(double value);

  // required double shortfrozenamount = 17;
  inline bool has_shortfrozenamount() const;
  inline void clear_shortfrozenamount();
  static const int kShortfrozenamountFieldNumber = 17;
  inline double shortfrozenamount() const;
  inline void set_shortfrozenamount(double value);

  // required int32 openvolume = 18;
  inline bool has_openvolume() const;
  inline void clear_openvolume();
  static const int kOpenvolumeFieldNumber = 18;
  inline ::google::protobuf::int32 openvolume() const;
  inline void set_openvolume(::google::protobuf::int32 value);

  // required int32 closevolume = 19;
  inline bool has_closevolume() const;
  inline void clear_closevolume();
  static const int kClosevolumeFieldNumber = 19;
  inline ::google::protobuf::int32 closevolume() const;
  inline void set_closevolume(::google::protobuf::int32 value);

  // required double openamount = 20;
  inline bool has_openamount() const;
  inline void clear_openamount();
  static const int kOpenamountFieldNumber = 20;
  inline double openamount() const;
  inline void set_openamount(double value);

  // required double closeamount = 21;
  inline bool has_closeamount() const;
  inline void clear_closeamount();
  static const int kCloseamountFieldNumber = 21;
  inline double closeamount() const;
  inline void set_closeamount(double value);

  // required double positioncost = 22;
  inline bool has_positioncost() const;
  inline void clear_positioncost();
  static const int kPositioncostFieldNumber = 22;
  inline double positioncost() const;
  inline void set_positioncost(double value);

  // required double premargin = 23;
  inline bool has_premargin() const;
  inline void clear_premargin();
  static const int kPremarginFieldNumber = 23;
  inline double premargin() const;
  inline void set_premargin(double value);

  // required double usemargin = 24;
  inline bool has_usemargin() const;
  inline void clear_usemargin();
  static const int kUsemarginFieldNumber = 24;
  inline double usemargin() const;
  inline void set_usemargin(double value);

  // required double frozenmargin = 25;
  inline bool has_frozenmargin() const;
  inline void clear_frozenmargin();
  static const int kFrozenmarginFieldNumber = 25;
  inline double frozenmargin() const;
  inline void set_frozenmargin(double value);

  // required double frozencash = 26;
  inline bool has_frozencash() const;
  inline void clear_frozencash();
  static const int kFrozencashFieldNumber = 26;
  inline double frozencash() const;
  inline void set_frozencash(double value);

  // required double frozencommission = 27;
  inline bool has_frozencommission() const;
  inline void clear_frozencommission();
  static const int kFrozencommissionFieldNumber = 27;
  inline double frozencommission() const;
  inline void set_frozencommission(double value);

  // required double cashin = 28;
  inline bool has_cashin() const;
  inline void clear_cashin();
  static const int kCashinFieldNumber = 28;
  inline double cashin() const;
  inline void set_cashin(double value);

  // required double commission = 29;
  inline bool has_commission() const;
  inline void clear_commission();
  static const int kCommissionFieldNumber = 29;
  inline double commission() const;
  inline void set_commission(double value);

  // required double closeprofit = 30;
  inline bool has_closeprofit() const;
  inline void clear_closeprofit();
  static const int kCloseprofitFieldNumber = 30;
  inline double closeprofit() const;
  inline void set_closeprofit(double value);

  // required double positionprofit = 31;
  inline bool has_positionprofit() const;
  inline void clear_positionprofit();
  static const int kPositionprofitFieldNumber = 31;
  inline double positionprofit() const;
  inline void set_positionprofit(double value);

  // required double presettlementprice = 32;
  inline bool has_presettlementprice() const;
  inline void clear_presettlementprice();
  static const int kPresettlementpriceFieldNumber = 32;
  inline double presettlementprice() const;
  inline void set_presettlementprice(double value);

  // required double settlementprice = 33;
  inline bool has_settlementprice() const;
  inline void clear_settlementprice();
  static const int kSettlementpriceFieldNumber = 33;
  inline double settlementprice() const;
  inline void set_settlementprice(double value);

  // required string tradingday = 34;
  inline bool has_tradingday() const;
  inline void clear_tradingday();
  static const int kTradingdayFieldNumber = 34;
  inline const ::std::string& tradingday() const;
  inline void set_tradingday(const ::std::string& value);
  inline void set_tradingday(const char* value);
  inline void set_tradingday(const char* value, size_t size);
  inline ::std::string* mutable_tradingday();
  inline ::std::string* release_tradingday();
  inline void set_allocated_tradingday(::std::string* tradingday);

  // required int32 settlementid = 35;
  inline bool has_settlementid() const;
  inline void clear_settlementid();
  static const int kSettlementidFieldNumber = 35;
  inline ::google::protobuf::int32 settlementid() const;
  inline void set_settlementid(::google::protobuf::int32 value);

  // required double opencost = 36;
  inline bool has_opencost() const;
  inline void clear_opencost();
  static const int kOpencostFieldNumber = 36;
  inline double opencost() const;
  inline void set_opencost(double value);

  // required double exchangemargin = 37;
  inline bool has_exchangemargin() const;
  inline void clear_exchangemargin();
  static const int kExchangemarginFieldNumber = 37;
  inline double exchangemargin() const;
  inline void set_exchangemargin(double value);

  // required int32 combposition = 38;
  inline bool has_combposition() const;
  inline void clear_combposition();
  static const int kCombpositionFieldNumber = 38;
  inline ::google::protobuf::int32 combposition() const;
  inline void set_combposition(::google::protobuf::int32 value);

  // required int32 comblongfrozen = 39;
  inline bool has_comblongfrozen() const;
  inline void clear_comblongfrozen();
  static const int kComblongfrozenFieldNumber = 39;
  inline ::google::protobuf::int32 comblongfrozen() const;
  inline void set_comblongfrozen(::google::protobuf::int32 value);

  // required int32 combshortfrozen = 40;
  inline bool has_combshortfrozen() const;
  inline void clear_combshortfrozen();
  static const int kCombshortfrozenFieldNumber = 40;
  inline ::google::protobuf::int32 combshortfrozen() const;
  inline void set_combshortfrozen(::google::protobuf::int32 value);

  // required double closeprofitbydate = 41;
  inline bool has_closeprofitbydate() const;
  inline void clear_closeprofitbydate();
  static const int kCloseprofitbydateFieldNumber = 41;
  inline double closeprofitbydate() const;
  inline void set_closeprofitbydate(double value);

  // required double closeprofitbytrade = 42;
  inline bool has_closeprofitbytrade() const;
  inline void clear_closeprofitbytrade();
  static const int kCloseprofitbytradeFieldNumber = 42;
  inline double closeprofitbytrade() const;
  inline void set_closeprofitbytrade(double value);

  // required int32 todayposition = 43;
  inline bool has_todayposition() const;
  inline void clear_todayposition();
  static const int kTodaypositionFieldNumber = 43;
  inline ::google::protobuf::int32 todayposition() const;
  inline void set_todayposition(::google::protobuf::int32 value);

  // required double marginratebymoney = 44;
  inline bool has_marginratebymoney() const;
  inline void clear_marginratebymoney();
  static const int kMarginratebymoneyFieldNumber = 44;
  inline double marginratebymoney() const;
  inline void set_marginratebymoney(double value);

  // required double marginratebyvolume = 45;
  inline bool has_marginratebyvolume() const;
  inline void clear_marginratebyvolume();
  static const int kMarginratebyvolumeFieldNumber = 45;
  inline double marginratebyvolume() const;
  inline void set_marginratebyvolume(double value);

  // @@protoc_insertion_point(class_scope:ctp.cp.Position)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_time_string();
  inline void clear_has_time_string();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_price_index();
  inline void clear_has_price_index();
  inline void set_has_stop_price();
  inline void clear_has_stop_price();
  inline void set_has_instrumentid();
  inline void clear_has_instrumentid();
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_investorid();
  inline void clear_has_investorid();
  inline void set_has_posidirection();
  inline void clear_has_posidirection();
  inline void set_has_hedgeflag();
  inline void clear_has_hedgeflag();
  inline void set_has_positiondate();
  inline void clear_has_positiondate();
  inline void set_has_ydposition();
  inline void clear_has_ydposition();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_longfrozen();
  inline void clear_has_longfrozen();
  inline void set_has_shortfrozen();
  inline void clear_has_shortfrozen();
  inline void set_has_longfrozenamount();
  inline void clear_has_longfrozenamount();
  inline void set_has_shortfrozenamount();
  inline void clear_has_shortfrozenamount();
  inline void set_has_openvolume();
  inline void clear_has_openvolume();
  inline void set_has_closevolume();
  inline void clear_has_closevolume();
  inline void set_has_openamount();
  inline void clear_has_openamount();
  inline void set_has_closeamount();
  inline void clear_has_closeamount();
  inline void set_has_positioncost();
  inline void clear_has_positioncost();
  inline void set_has_premargin();
  inline void clear_has_premargin();
  inline void set_has_usemargin();
  inline void clear_has_usemargin();
  inline void set_has_frozenmargin();
  inline void clear_has_frozenmargin();
  inline void set_has_frozencash();
  inline void clear_has_frozencash();
  inline void set_has_frozencommission();
  inline void clear_has_frozencommission();
  inline void set_has_cashin();
  inline void clear_has_cashin();
  inline void set_has_commission();
  inline void clear_has_commission();
  inline void set_has_closeprofit();
  inline void clear_has_closeprofit();
  inline void set_has_positionprofit();
  inline void clear_has_positionprofit();
  inline void set_has_presettlementprice();
  inline void clear_has_presettlementprice();
  inline void set_has_settlementprice();
  inline void clear_has_settlementprice();
  inline void set_has_tradingday();
  inline void clear_has_tradingday();
  inline void set_has_settlementid();
  inline void clear_has_settlementid();
  inline void set_has_opencost();
  inline void clear_has_opencost();
  inline void set_has_exchangemargin();
  inline void clear_has_exchangemargin();
  inline void set_has_combposition();
  inline void clear_has_combposition();
  inline void set_has_comblongfrozen();
  inline void clear_has_comblongfrozen();
  inline void set_has_combshortfrozen();
  inline void clear_has_combshortfrozen();
  inline void set_has_closeprofitbydate();
  inline void clear_has_closeprofitbydate();
  inline void set_has_closeprofitbytrade();
  inline void clear_has_closeprofitbytrade();
  inline void set_has_todayposition();
  inline void clear_has_todayposition();
  inline void set_has_marginratebymoney();
  inline void clear_has_marginratebymoney();
  inline void set_has_marginratebyvolume();
  inline void clear_has_marginratebyvolume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* time_string_;
  ::std::string* user_;
  double price_index_;
  double stop_price_;
  ::std::string* instrumentid_;
  ::std::string* brokerid_;
  ::std::string* investorid_;
  ::google::protobuf::int32 posidirection_;
  ::google::protobuf::int32 hedgeflag_;
  ::google::protobuf::int32 positiondate_;
  ::google::protobuf::int32 ydposition_;
  ::google::protobuf::int32 position_;
  ::google::protobuf::int32 longfrozen_;
  double longfrozenamount_;
  ::google::protobuf::int32 shortfrozen_;
  ::google::protobuf::int32 openvolume_;
  double shortfrozenamount_;
  double openamount_;
  double closeamount_;
  double positioncost_;
  double premargin_;
  double usemargin_;
  double frozenmargin_;
  double frozencash_;
  double frozencommission_;
  ::google::protobuf::int32 closevolume_;
  ::google::protobuf::int32 settlementid_;
  double cashin_;
  double commission_;
  double closeprofit_;
  double positionprofit_;
  double presettlementprice_;
  double settlementprice_;
  ::std::string* tradingday_;
  double opencost_;
  double exchangemargin_;
  ::google::protobuf::int32 combposition_;
  ::google::protobuf::int32 comblongfrozen_;
  double closeprofitbydate_;
  ::google::protobuf::int32 combshortfrozen_;
  ::google::protobuf::int32 todayposition_;
  double closeprofitbytrade_;
  double marginratebymoney_;
  double marginratebyvolume_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(45 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Account : public ::google::protobuf::Message {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  Account* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // required string time_string = 2;
  inline bool has_time_string() const;
  inline void clear_time_string();
  static const int kTimeStringFieldNumber = 2;
  inline const ::std::string& time_string() const;
  inline void set_time_string(const ::std::string& value);
  inline void set_time_string(const char* value);
  inline void set_time_string(const char* value, size_t size);
  inline ::std::string* mutable_time_string();
  inline ::std::string* release_time_string();
  inline void set_allocated_time_string(::std::string* time_string);

  // required string user = 3;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string brokerid = 4;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokeridFieldNumber = 4;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  inline void set_allocated_brokerid(::std::string* brokerid);

  // required string accountid = 5;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 5;
  inline const ::std::string& accountid() const;
  inline void set_accountid(const ::std::string& value);
  inline void set_accountid(const char* value);
  inline void set_accountid(const char* value, size_t size);
  inline ::std::string* mutable_accountid();
  inline ::std::string* release_accountid();
  inline void set_allocated_accountid(::std::string* accountid);

  // required double premortgage = 6;
  inline bool has_premortgage() const;
  inline void clear_premortgage();
  static const int kPremortgageFieldNumber = 6;
  inline double premortgage() const;
  inline void set_premortgage(double value);

  // required double precredit = 7;
  inline bool has_precredit() const;
  inline void clear_precredit();
  static const int kPrecreditFieldNumber = 7;
  inline double precredit() const;
  inline void set_precredit(double value);

  // required double predeposit = 8;
  inline bool has_predeposit() const;
  inline void clear_predeposit();
  static const int kPredepositFieldNumber = 8;
  inline double predeposit() const;
  inline void set_predeposit(double value);

  // required double prebalance = 9;
  inline bool has_prebalance() const;
  inline void clear_prebalance();
  static const int kPrebalanceFieldNumber = 9;
  inline double prebalance() const;
  inline void set_prebalance(double value);

  // required double premargin = 10;
  inline bool has_premargin() const;
  inline void clear_premargin();
  static const int kPremarginFieldNumber = 10;
  inline double premargin() const;
  inline void set_premargin(double value);

  // required double interestbase = 11;
  inline bool has_interestbase() const;
  inline void clear_interestbase();
  static const int kInterestbaseFieldNumber = 11;
  inline double interestbase() const;
  inline void set_interestbase(double value);

  // required double interest = 12;
  inline bool has_interest() const;
  inline void clear_interest();
  static const int kInterestFieldNumber = 12;
  inline double interest() const;
  inline void set_interest(double value);

  // required double deposit = 13;
  inline bool has_deposit() const;
  inline void clear_deposit();
  static const int kDepositFieldNumber = 13;
  inline double deposit() const;
  inline void set_deposit(double value);

  // required double withdraw = 14;
  inline bool has_withdraw() const;
  inline void clear_withdraw();
  static const int kWithdrawFieldNumber = 14;
  inline double withdraw() const;
  inline void set_withdraw(double value);

  // required double frozenmargin = 15;
  inline bool has_frozenmargin() const;
  inline void clear_frozenmargin();
  static const int kFrozenmarginFieldNumber = 15;
  inline double frozenmargin() const;
  inline void set_frozenmargin(double value);

  // required double frozencash = 16;
  inline bool has_frozencash() const;
  inline void clear_frozencash();
  static const int kFrozencashFieldNumber = 16;
  inline double frozencash() const;
  inline void set_frozencash(double value);

  // required double frozencommission = 17;
  inline bool has_frozencommission() const;
  inline void clear_frozencommission();
  static const int kFrozencommissionFieldNumber = 17;
  inline double frozencommission() const;
  inline void set_frozencommission(double value);

  // required double currmargin = 18;
  inline bool has_currmargin() const;
  inline void clear_currmargin();
  static const int kCurrmarginFieldNumber = 18;
  inline double currmargin() const;
  inline void set_currmargin(double value);

  // required double cashin = 19;
  inline bool has_cashin() const;
  inline void clear_cashin();
  static const int kCashinFieldNumber = 19;
  inline double cashin() const;
  inline void set_cashin(double value);

  // required double commission = 20;
  inline bool has_commission() const;
  inline void clear_commission();
  static const int kCommissionFieldNumber = 20;
  inline double commission() const;
  inline void set_commission(double value);

  // required double closeprofit = 21;
  inline bool has_closeprofit() const;
  inline void clear_closeprofit();
  static const int kCloseprofitFieldNumber = 21;
  inline double closeprofit() const;
  inline void set_closeprofit(double value);

  // required double positionprofit = 22;
  inline bool has_positionprofit() const;
  inline void clear_positionprofit();
  static const int kPositionprofitFieldNumber = 22;
  inline double positionprofit() const;
  inline void set_positionprofit(double value);

  // required double balance = 23;
  inline bool has_balance() const;
  inline void clear_balance();
  static const int kBalanceFieldNumber = 23;
  inline double balance() const;
  inline void set_balance(double value);

  // required double available = 24;
  inline bool has_available() const;
  inline void clear_available();
  static const int kAvailableFieldNumber = 24;
  inline double available() const;
  inline void set_available(double value);

  // required double withdrawquota = 25;
  inline bool has_withdrawquota() const;
  inline void clear_withdrawquota();
  static const int kWithdrawquotaFieldNumber = 25;
  inline double withdrawquota() const;
  inline void set_withdrawquota(double value);

  // required double reserve = 26;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 26;
  inline double reserve() const;
  inline void set_reserve(double value);

  // required string tradingday = 27;
  inline bool has_tradingday() const;
  inline void clear_tradingday();
  static const int kTradingdayFieldNumber = 27;
  inline const ::std::string& tradingday() const;
  inline void set_tradingday(const ::std::string& value);
  inline void set_tradingday(const char* value);
  inline void set_tradingday(const char* value, size_t size);
  inline ::std::string* mutable_tradingday();
  inline ::std::string* release_tradingday();
  inline void set_allocated_tradingday(::std::string* tradingday);

  // required int32 settlementid = 28;
  inline bool has_settlementid() const;
  inline void clear_settlementid();
  static const int kSettlementidFieldNumber = 28;
  inline ::google::protobuf::int32 settlementid() const;
  inline void set_settlementid(::google::protobuf::int32 value);

  // required double credit = 29;
  inline bool has_credit() const;
  inline void clear_credit();
  static const int kCreditFieldNumber = 29;
  inline double credit() const;
  inline void set_credit(double value);

  // required double mortgage = 30;
  inline bool has_mortgage() const;
  inline void clear_mortgage();
  static const int kMortgageFieldNumber = 30;
  inline double mortgage() const;
  inline void set_mortgage(double value);

  // required double exchangemargin = 31;
  inline bool has_exchangemargin() const;
  inline void clear_exchangemargin();
  static const int kExchangemarginFieldNumber = 31;
  inline double exchangemargin() const;
  inline void set_exchangemargin(double value);

  // @@protoc_insertion_point(class_scope:ctp.cp.Account)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_time_string();
  inline void clear_has_time_string();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_premortgage();
  inline void clear_has_premortgage();
  inline void set_has_precredit();
  inline void clear_has_precredit();
  inline void set_has_predeposit();
  inline void clear_has_predeposit();
  inline void set_has_prebalance();
  inline void clear_has_prebalance();
  inline void set_has_premargin();
  inline void clear_has_premargin();
  inline void set_has_interestbase();
  inline void clear_has_interestbase();
  inline void set_has_interest();
  inline void clear_has_interest();
  inline void set_has_deposit();
  inline void clear_has_deposit();
  inline void set_has_withdraw();
  inline void clear_has_withdraw();
  inline void set_has_frozenmargin();
  inline void clear_has_frozenmargin();
  inline void set_has_frozencash();
  inline void clear_has_frozencash();
  inline void set_has_frozencommission();
  inline void clear_has_frozencommission();
  inline void set_has_currmargin();
  inline void clear_has_currmargin();
  inline void set_has_cashin();
  inline void clear_has_cashin();
  inline void set_has_commission();
  inline void clear_has_commission();
  inline void set_has_closeprofit();
  inline void clear_has_closeprofit();
  inline void set_has_positionprofit();
  inline void clear_has_positionprofit();
  inline void set_has_balance();
  inline void clear_has_balance();
  inline void set_has_available();
  inline void clear_has_available();
  inline void set_has_withdrawquota();
  inline void clear_has_withdrawquota();
  inline void set_has_reserve();
  inline void clear_has_reserve();
  inline void set_has_tradingday();
  inline void clear_has_tradingday();
  inline void set_has_settlementid();
  inline void clear_has_settlementid();
  inline void set_has_credit();
  inline void clear_has_credit();
  inline void set_has_mortgage();
  inline void clear_has_mortgage();
  inline void set_has_exchangemargin();
  inline void clear_has_exchangemargin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* time_string_;
  ::std::string* user_;
  ::std::string* brokerid_;
  ::std::string* accountid_;
  double premortgage_;
  double precredit_;
  double predeposit_;
  double prebalance_;
  double premargin_;
  double interestbase_;
  double interest_;
  double deposit_;
  double withdraw_;
  double frozenmargin_;
  double frozencash_;
  double frozencommission_;
  double currmargin_;
  double cashin_;
  double commission_;
  double closeprofit_;
  double positionprofit_;
  double balance_;
  double available_;
  double withdrawquota_;
  double reserve_;
  ::std::string* tradingday_;
  double credit_;
  double mortgage_;
  double exchangemargin_;
  ::google::protobuf::int32 settlementid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class BacktestingExpectAssetList : public ::google::protobuf::Message {
 public:
  BacktestingExpectAssetList();
  virtual ~BacktestingExpectAssetList();

  BacktestingExpectAssetList(const BacktestingExpectAssetList& from);

  inline BacktestingExpectAssetList& operator=(const BacktestingExpectAssetList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BacktestingExpectAssetList& default_instance();

  void Swap(BacktestingExpectAssetList* other);

  // implements Message ----------------------------------------------

  BacktestingExpectAssetList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BacktestingExpectAssetList& from);
  void MergeFrom(const BacktestingExpectAssetList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // required string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 total = 4;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 4;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // repeated double data = 5;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline double data(int index) const;
  inline void set_data(int index, double value);
  inline void add_data(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      data() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:ctp.cp.BacktestingExpectAssetList)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* table_name_;
  ::std::string* type_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 total_;
  ::google::protobuf::RepeatedField< double > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static BacktestingExpectAssetList* default_instance_;
};
// -------------------------------------------------------------------

class BacktestingExpectAssetQuery : public ::google::protobuf::Message {
 public:
  BacktestingExpectAssetQuery();
  virtual ~BacktestingExpectAssetQuery();

  BacktestingExpectAssetQuery(const BacktestingExpectAssetQuery& from);

  inline BacktestingExpectAssetQuery& operator=(const BacktestingExpectAssetQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BacktestingExpectAssetQuery& default_instance();

  void Swap(BacktestingExpectAssetQuery* other);

  // implements Message ----------------------------------------------

  BacktestingExpectAssetQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BacktestingExpectAssetQuery& from);
  void MergeFrom(const BacktestingExpectAssetQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // required string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ctp.cp.BacktestingExpectAssetQuery)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* table_name_;
  ::std::string* type_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static BacktestingExpectAssetQuery* default_instance_;
};
// -------------------------------------------------------------------

class BacktestingResultSave2DBRequery_BacktestingResultItem : public ::google::protobuf::Message {
 public:
  BacktestingResultSave2DBRequery_BacktestingResultItem();
  virtual ~BacktestingResultSave2DBRequery_BacktestingResultItem();

  BacktestingResultSave2DBRequery_BacktestingResultItem(const BacktestingResultSave2DBRequery_BacktestingResultItem& from);

  inline BacktestingResultSave2DBRequery_BacktestingResultItem& operator=(const BacktestingResultSave2DBRequery_BacktestingResultItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BacktestingResultSave2DBRequery_BacktestingResultItem& default_instance();

  void Swap(BacktestingResultSave2DBRequery_BacktestingResultItem* other);

  // implements Message ----------------------------------------------

  BacktestingResultSave2DBRequery_BacktestingResultItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BacktestingResultSave2DBRequery_BacktestingResultItem& from);
  void MergeFrom(const BacktestingResultSave2DBRequery_BacktestingResultItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string time_string = 1;
  inline bool has_time_string() const;
  inline void clear_time_string();
  static const int kTimeStringFieldNumber = 1;
  inline const ::std::string& time_string() const;
  inline void set_time_string(const ::std::string& value);
  inline void set_time_string(const char* value);
  inline void set_time_string(const char* value, size_t size);
  inline ::std::string* mutable_time_string();
  inline ::std::string* release_time_string();
  inline void set_allocated_time_string(::std::string* time_string);

  // required int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // required double money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline double money() const;
  inline void set_money(double value);

  // @@protoc_insertion_point(class_scope:ctp.cp.BacktestingResultSave2DBRequery.BacktestingResultItem)
 private:
  inline void set_has_time_string();
  inline void clear_has_time_string();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* time_string_;
  ::google::protobuf::int64 time_;
  double money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static BacktestingResultSave2DBRequery_BacktestingResultItem* default_instance_;
};
// -------------------------------------------------------------------

class BacktestingResultSave2DBRequery : public ::google::protobuf::Message {
 public:
  BacktestingResultSave2DBRequery();
  virtual ~BacktestingResultSave2DBRequery();

  BacktestingResultSave2DBRequery(const BacktestingResultSave2DBRequery& from);

  inline BacktestingResultSave2DBRequery& operator=(const BacktestingResultSave2DBRequery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BacktestingResultSave2DBRequery& default_instance();

  void Swap(BacktestingResultSave2DBRequery* other);

  // implements Message ----------------------------------------------

  BacktestingResultSave2DBRequery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BacktestingResultSave2DBRequery& from);
  void MergeFrom(const BacktestingResultSave2DBRequery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BacktestingResultSave2DBRequery_BacktestingResultItem BacktestingResultItem;

  // accessors -------------------------------------------------------

  // required string table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // required int32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // required int32 chart = 3;
  inline bool has_chart() const;
  inline void clear_chart();
  static const int kChartFieldNumber = 3;
  inline ::google::protobuf::int32 chart() const;
  inline void set_chart(::google::protobuf::int32 value);

  // repeated .ctp.cp.BacktestingResultSave2DBRequery.BacktestingResultItem data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem& data(int index) const;
  inline ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem* mutable_data(int index);
  inline ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:ctp.cp.BacktestingResultSave2DBRequery)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_chart();
  inline void clear_has_chart();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* table_name_;
  ::google::protobuf::int32 total_;
  ::google::protobuf::int32 chart_;
  ::google::protobuf::RepeatedPtrField< ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static BacktestingResultSave2DBRequery* default_instance_;
};
// -------------------------------------------------------------------

class BacktestingResultSave2DBResponse : public ::google::protobuf::Message {
 public:
  BacktestingResultSave2DBResponse();
  virtual ~BacktestingResultSave2DBResponse();

  BacktestingResultSave2DBResponse(const BacktestingResultSave2DBResponse& from);

  inline BacktestingResultSave2DBResponse& operator=(const BacktestingResultSave2DBResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BacktestingResultSave2DBResponse& default_instance();

  void Swap(BacktestingResultSave2DBResponse* other);

  // implements Message ----------------------------------------------

  BacktestingResultSave2DBResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BacktestingResultSave2DBResponse& from);
  void MergeFrom(const BacktestingResultSave2DBResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::std::string& table_name() const;
  inline void set_table_name(const ::std::string& value);
  inline void set_table_name(const char* value);
  inline void set_table_name(const char* value, size_t size);
  inline ::std::string* mutable_table_name();
  inline ::std::string* release_table_name();
  inline void set_allocated_table_name(::std::string* table_name);

  // required int32 progress = 2;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 2;
  inline ::google::protobuf::int32 progress() const;
  inline void set_progress(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ctp.cp.BacktestingResultSave2DBResponse)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_progress();
  inline void clear_has_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* table_name_;
  ::google::protobuf::int32 progress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static BacktestingResultSave2DBResponse* default_instance_;
};
// -------------------------------------------------------------------

class test1 : public ::google::protobuf::Message {
 public:
  test1();
  virtual ~test1();

  test1(const test1& from);

  inline test1& operator=(const test1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const test1& default_instance();

  void Swap(test1* other);

  // implements Message ----------------------------------------------

  test1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const test1& from);
  void MergeFrom(const test1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string s = 1;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 1;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:ctp.cp.test1)
 private:
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* s_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static test1* default_instance_;
};
// -------------------------------------------------------------------

class test2 : public ::google::protobuf::Message {
 public:
  test2();
  virtual ~test2();

  test2(const test2& from);

  inline test2& operator=(const test2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const test2& default_instance();

  void Swap(test2* other);

  // implements Message ----------------------------------------------

  test2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const test2& from);
  void MergeFrom(const test2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string s2 = 1;
  inline bool has_s2() const;
  inline void clear_s2();
  static const int kS2FieldNumber = 1;
  inline const ::std::string& s2() const;
  inline void set_s2(const ::std::string& value);
  inline void set_s2(const char* value);
  inline void set_s2(const char* value, size_t size);
  inline ::std::string* mutable_s2();
  inline ::std::string* release_s2();
  inline void set_allocated_s2(::std::string* s2);

  // required .ctp.cp.test1 t2 = 2;
  inline bool has_t2() const;
  inline void clear_t2();
  static const int kT2FieldNumber = 2;
  inline const ::ctp::cp::test1& t2() const;
  inline ::ctp::cp::test1* mutable_t2();
  inline ::ctp::cp::test1* release_t2();
  inline void set_allocated_t2(::ctp::cp::test1* t2);

  // @@protoc_insertion_point(class_scope:ctp.cp.test2)
 private:
  inline void set_has_s2();
  inline void clear_has_s2();
  inline void set_has_t2();
  inline void clear_has_t2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* s2_;
  ::ctp::cp::test1* t2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cp_5fcomunication_2eproto();
  friend void protobuf_AssignDesc_cp_5fcomunication_2eproto();
  friend void protobuf_ShutdownFile_cp_5fcomunication_2eproto();

  void InitAsDefaultInstance();
  static test2* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// required string cmd = 1;
inline bool Command::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& Command::cmd() const {
  return *cmd_;
}
inline void Command::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void Command::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void Command::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* Command::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string params = 2;
inline int Command::params_size() const {
  return params_.size();
}
inline void Command::clear_params() {
  params_.Clear();
}
inline const ::std::string& Command::params(int index) const {
  return params_.Get(index);
}
inline ::std::string* Command::mutable_params(int index) {
  return params_.Mutable(index);
}
inline void Command::set_params(int index, const ::std::string& value) {
  params_.Mutable(index)->assign(value);
}
inline void Command::set_params(int index, const char* value) {
  params_.Mutable(index)->assign(value);
}
inline void Command::set_params(int index, const char* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::add_params() {
  return params_.Add();
}
inline void Command::add_params(const ::std::string& value) {
  params_.Add()->assign(value);
}
inline void Command::add_params(const char* value) {
  params_.Add()->assign(value);
}
inline void Command::add_params(const char* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Command::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Command::mutable_params() {
  return &params_;
}

// -------------------------------------------------------------------

// MQLevel

// required string type = 1;
inline bool MQLevel::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MQLevel::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MQLevel::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MQLevel::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& MQLevel::type() const {
  return *type_;
}
inline void MQLevel::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MQLevel::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MQLevel::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MQLevel::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* MQLevel::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MQLevel::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 2;
inline bool MQLevel::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MQLevel::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MQLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MQLevel::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 MQLevel::level() const {
  return level_;
}
inline void MQLevel::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string utc_string = 3;
inline bool MQLevel::has_utc_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MQLevel::set_has_utc_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MQLevel::clear_has_utc_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MQLevel::clear_utc_string() {
  if (utc_string_ != &::google::protobuf::internal::kEmptyString) {
    utc_string_->clear();
  }
  clear_has_utc_string();
}
inline const ::std::string& MQLevel::utc_string() const {
  return *utc_string_;
}
inline void MQLevel::set_utc_string(const ::std::string& value) {
  set_has_utc_string();
  if (utc_string_ == &::google::protobuf::internal::kEmptyString) {
    utc_string_ = new ::std::string;
  }
  utc_string_->assign(value);
}
inline void MQLevel::set_utc_string(const char* value) {
  set_has_utc_string();
  if (utc_string_ == &::google::protobuf::internal::kEmptyString) {
    utc_string_ = new ::std::string;
  }
  utc_string_->assign(value);
}
inline void MQLevel::set_utc_string(const char* value, size_t size) {
  set_has_utc_string();
  if (utc_string_ == &::google::protobuf::internal::kEmptyString) {
    utc_string_ = new ::std::string;
  }
  utc_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MQLevel::mutable_utc_string() {
  set_has_utc_string();
  if (utc_string_ == &::google::protobuf::internal::kEmptyString) {
    utc_string_ = new ::std::string;
  }
  return utc_string_;
}
inline ::std::string* MQLevel::release_utc_string() {
  clear_has_utc_string();
  if (utc_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = utc_string_;
    utc_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MQLevel::set_allocated_utc_string(::std::string* utc_string) {
  if (utc_string_ != &::google::protobuf::internal::kEmptyString) {
    delete utc_string_;
  }
  if (utc_string) {
    set_has_utc_string();
    utc_string_ = utc_string;
  } else {
    clear_has_utc_string();
    utc_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 utc = 4;
inline bool MQLevel::has_utc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MQLevel::set_has_utc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MQLevel::clear_has_utc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MQLevel::clear_utc() {
  utc_ = GOOGLE_LONGLONG(0);
  clear_has_utc();
}
inline ::google::protobuf::int64 MQLevel::utc() const {
  return utc_;
}
inline void MQLevel::set_utc(::google::protobuf::int64 value) {
  set_has_utc();
  utc_ = value;
}

// required double open_price = 5;
inline bool MQLevel::has_open_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MQLevel::set_has_open_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MQLevel::clear_has_open_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MQLevel::clear_open_price() {
  open_price_ = 0;
  clear_has_open_price();
}
inline double MQLevel::open_price() const {
  return open_price_;
}
inline void MQLevel::set_open_price(double value) {
  set_has_open_price();
  open_price_ = value;
}

// required double high_price = 6;
inline bool MQLevel::has_high_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MQLevel::set_has_high_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MQLevel::clear_has_high_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MQLevel::clear_high_price() {
  high_price_ = 0;
  clear_has_high_price();
}
inline double MQLevel::high_price() const {
  return high_price_;
}
inline void MQLevel::set_high_price(double value) {
  set_has_high_price();
  high_price_ = value;
}

// required double low_price = 7;
inline bool MQLevel::has_low_price() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MQLevel::set_has_low_price() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MQLevel::clear_has_low_price() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MQLevel::clear_low_price() {
  low_price_ = 0;
  clear_has_low_price();
}
inline double MQLevel::low_price() const {
  return low_price_;
}
inline void MQLevel::set_low_price(double value) {
  set_has_low_price();
  low_price_ = value;
}

// required double close_price = 8;
inline bool MQLevel::has_close_price() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MQLevel::set_has_close_price() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MQLevel::clear_has_close_price() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MQLevel::clear_close_price() {
  close_price_ = 0;
  clear_has_close_price();
}
inline double MQLevel::close_price() const {
  return close_price_;
}
inline void MQLevel::set_close_price(double value) {
  set_has_close_price();
  close_price_ = value;
}

// required int32 volumn = 9;
inline bool MQLevel::has_volumn() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MQLevel::set_has_volumn() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MQLevel::clear_has_volumn() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MQLevel::clear_volumn() {
  volumn_ = 0;
  clear_has_volumn();
}
inline ::google::protobuf::int32 MQLevel::volumn() const {
  return volumn_;
}
inline void MQLevel::set_volumn(::google::protobuf::int32 value) {
  set_has_volumn();
  volumn_ = value;
}

// required int32 counter = 10;
inline bool MQLevel::has_counter() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MQLevel::set_has_counter() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MQLevel::clear_has_counter() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MQLevel::clear_counter() {
  counter_ = 0;
  clear_has_counter();
}
inline ::google::protobuf::int32 MQLevel::counter() const {
  return counter_;
}
inline void MQLevel::set_counter(::google::protobuf::int32 value) {
  set_has_counter();
  counter_ = value;
}

// -------------------------------------------------------------------

// TradeResult

// required string user = 1;
inline bool TradeResult::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeResult::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeResult::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeResult::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& TradeResult::user() const {
  return *user_;
}
inline void TradeResult::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void TradeResult::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void TradeResult::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeResult::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* TradeResult::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeResult::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string type = 2;
inline bool TradeResult::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeResult::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeResult::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeResult::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& TradeResult::type() const {
  return *type_;
}
inline void TradeResult::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void TradeResult::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void TradeResult::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeResult::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* TradeResult::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeResult::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ms_name = 3;
inline bool TradeResult::has_ms_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TradeResult::set_has_ms_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TradeResult::clear_has_ms_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TradeResult::clear_ms_name() {
  if (ms_name_ != &::google::protobuf::internal::kEmptyString) {
    ms_name_->clear();
  }
  clear_has_ms_name();
}
inline const ::std::string& TradeResult::ms_name() const {
  return *ms_name_;
}
inline void TradeResult::set_ms_name(const ::std::string& value) {
  set_has_ms_name();
  if (ms_name_ == &::google::protobuf::internal::kEmptyString) {
    ms_name_ = new ::std::string;
  }
  ms_name_->assign(value);
}
inline void TradeResult::set_ms_name(const char* value) {
  set_has_ms_name();
  if (ms_name_ == &::google::protobuf::internal::kEmptyString) {
    ms_name_ = new ::std::string;
  }
  ms_name_->assign(value);
}
inline void TradeResult::set_ms_name(const char* value, size_t size) {
  set_has_ms_name();
  if (ms_name_ == &::google::protobuf::internal::kEmptyString) {
    ms_name_ = new ::std::string;
  }
  ms_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeResult::mutable_ms_name() {
  set_has_ms_name();
  if (ms_name_ == &::google::protobuf::internal::kEmptyString) {
    ms_name_ = new ::std::string;
  }
  return ms_name_;
}
inline ::std::string* TradeResult::release_ms_name() {
  clear_has_ms_name();
  if (ms_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ms_name_;
    ms_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeResult::set_allocated_ms_name(::std::string* ms_name) {
  if (ms_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ms_name_;
  }
  if (ms_name) {
    set_has_ms_name();
    ms_name_ = ms_name;
  } else {
    clear_has_ms_name();
    ms_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string os_name = 4;
inline bool TradeResult::has_os_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TradeResult::set_has_os_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TradeResult::clear_has_os_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TradeResult::clear_os_name() {
  if (os_name_ != &::google::protobuf::internal::kEmptyString) {
    os_name_->clear();
  }
  clear_has_os_name();
}
inline const ::std::string& TradeResult::os_name() const {
  return *os_name_;
}
inline void TradeResult::set_os_name(const ::std::string& value) {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  os_name_->assign(value);
}
inline void TradeResult::set_os_name(const char* value) {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  os_name_->assign(value);
}
inline void TradeResult::set_os_name(const char* value, size_t size) {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  os_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeResult::mutable_os_name() {
  set_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    os_name_ = new ::std::string;
  }
  return os_name_;
}
inline ::std::string* TradeResult::release_os_name() {
  clear_has_os_name();
  if (os_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_name_;
    os_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeResult::set_allocated_os_name(::std::string* os_name) {
  if (os_name_ != &::google::protobuf::internal::kEmptyString) {
    delete os_name_;
  }
  if (os_name) {
    set_has_os_name();
    os_name_ = os_name;
  } else {
    clear_has_os_name();
    os_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ms_id = 5;
inline bool TradeResult::has_ms_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TradeResult::set_has_ms_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TradeResult::clear_has_ms_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TradeResult::clear_ms_id() {
  if (ms_id_ != &::google::protobuf::internal::kEmptyString) {
    ms_id_->clear();
  }
  clear_has_ms_id();
}
inline const ::std::string& TradeResult::ms_id() const {
  return *ms_id_;
}
inline void TradeResult::set_ms_id(const ::std::string& value) {
  set_has_ms_id();
  if (ms_id_ == &::google::protobuf::internal::kEmptyString) {
    ms_id_ = new ::std::string;
  }
  ms_id_->assign(value);
}
inline void TradeResult::set_ms_id(const char* value) {
  set_has_ms_id();
  if (ms_id_ == &::google::protobuf::internal::kEmptyString) {
    ms_id_ = new ::std::string;
  }
  ms_id_->assign(value);
}
inline void TradeResult::set_ms_id(const char* value, size_t size) {
  set_has_ms_id();
  if (ms_id_ == &::google::protobuf::internal::kEmptyString) {
    ms_id_ = new ::std::string;
  }
  ms_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeResult::mutable_ms_id() {
  set_has_ms_id();
  if (ms_id_ == &::google::protobuf::internal::kEmptyString) {
    ms_id_ = new ::std::string;
  }
  return ms_id_;
}
inline ::std::string* TradeResult::release_ms_id() {
  clear_has_ms_id();
  if (ms_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ms_id_;
    ms_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeResult::set_allocated_ms_id(::std::string* ms_id) {
  if (ms_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ms_id_;
  }
  if (ms_id) {
    set_has_ms_id();
    ms_id_ = ms_id;
  } else {
    clear_has_ms_id();
    ms_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string os_id = 6;
inline bool TradeResult::has_os_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TradeResult::set_has_os_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TradeResult::clear_has_os_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TradeResult::clear_os_id() {
  if (os_id_ != &::google::protobuf::internal::kEmptyString) {
    os_id_->clear();
  }
  clear_has_os_id();
}
inline const ::std::string& TradeResult::os_id() const {
  return *os_id_;
}
inline void TradeResult::set_os_id(const ::std::string& value) {
  set_has_os_id();
  if (os_id_ == &::google::protobuf::internal::kEmptyString) {
    os_id_ = new ::std::string;
  }
  os_id_->assign(value);
}
inline void TradeResult::set_os_id(const char* value) {
  set_has_os_id();
  if (os_id_ == &::google::protobuf::internal::kEmptyString) {
    os_id_ = new ::std::string;
  }
  os_id_->assign(value);
}
inline void TradeResult::set_os_id(const char* value, size_t size) {
  set_has_os_id();
  if (os_id_ == &::google::protobuf::internal::kEmptyString) {
    os_id_ = new ::std::string;
  }
  os_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeResult::mutable_os_id() {
  set_has_os_id();
  if (os_id_ == &::google::protobuf::internal::kEmptyString) {
    os_id_ = new ::std::string;
  }
  return os_id_;
}
inline ::std::string* TradeResult::release_os_id() {
  clear_has_os_id();
  if (os_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_id_;
    os_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeResult::set_allocated_os_id(::std::string* os_id) {
  if (os_id_ != &::google::protobuf::internal::kEmptyString) {
    delete os_id_;
  }
  if (os_id) {
    set_has_os_id();
    os_id_ = os_id;
  } else {
    clear_has_os_id();
    os_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 ms_time = 7;
inline bool TradeResult::has_ms_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TradeResult::set_has_ms_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TradeResult::clear_has_ms_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TradeResult::clear_ms_time() {
  ms_time_ = GOOGLE_LONGLONG(0);
  clear_has_ms_time();
}
inline ::google::protobuf::int64 TradeResult::ms_time() const {
  return ms_time_;
}
inline void TradeResult::set_ms_time(::google::protobuf::int64 value) {
  set_has_ms_time();
  ms_time_ = value;
}

// required double total_cash = 8;
inline bool TradeResult::has_total_cash() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TradeResult::set_has_total_cash() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TradeResult::clear_has_total_cash() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TradeResult::clear_total_cash() {
  total_cash_ = 0;
  clear_has_total_cash();
}
inline double TradeResult::total_cash() const {
  return total_cash_;
}
inline void TradeResult::set_total_cash(double value) {
  set_has_total_cash();
  total_cash_ = value;
}

// required double average_price = 9;
inline bool TradeResult::has_average_price() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TradeResult::set_has_average_price() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TradeResult::clear_has_average_price() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TradeResult::clear_average_price() {
  average_price_ = 0;
  clear_has_average_price();
}
inline double TradeResult::average_price() const {
  return average_price_;
}
inline void TradeResult::set_average_price(double value) {
  set_has_average_price();
  average_price_ = value;
}

// required double ms_price = 10;
inline bool TradeResult::has_ms_price() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TradeResult::set_has_ms_price() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TradeResult::clear_has_ms_price() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TradeResult::clear_ms_price() {
  ms_price_ = 0;
  clear_has_ms_price();
}
inline double TradeResult::ms_price() const {
  return ms_price_;
}
inline void TradeResult::set_ms_price(double value) {
  set_has_ms_price();
  ms_price_ = value;
}

// required int32 total_volumn = 11;
inline bool TradeResult::has_total_volumn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TradeResult::set_has_total_volumn() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TradeResult::clear_has_total_volumn() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TradeResult::clear_total_volumn() {
  total_volumn_ = 0;
  clear_has_total_volumn();
}
inline ::google::protobuf::int32 TradeResult::total_volumn() const {
  return total_volumn_;
}
inline void TradeResult::set_total_volumn(::google::protobuf::int32 value) {
  set_has_total_volumn();
  total_volumn_ = value;
}

// required int32 traded_volumn = 12;
inline bool TradeResult::has_traded_volumn() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TradeResult::set_has_traded_volumn() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TradeResult::clear_has_traded_volumn() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TradeResult::clear_traded_volumn() {
  traded_volumn_ = 0;
  clear_has_traded_volumn();
}
inline ::google::protobuf::int32 TradeResult::traded_volumn() const {
  return traded_volumn_;
}
inline void TradeResult::set_traded_volumn(::google::protobuf::int32 value) {
  set_has_traded_volumn();
  traded_volumn_ = value;
}

// required int32 oc = 13;
inline bool TradeResult::has_oc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TradeResult::set_has_oc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TradeResult::clear_has_oc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TradeResult::clear_oc() {
  oc_ = 0;
  clear_has_oc();
}
inline ::google::protobuf::int32 TradeResult::oc() const {
  return oc_;
}
inline void TradeResult::set_oc(::google::protobuf::int32 value) {
  set_has_oc();
  oc_ = value;
}

// required int32 bs = 14;
inline bool TradeResult::has_bs() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TradeResult::set_has_bs() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TradeResult::clear_has_bs() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TradeResult::clear_bs() {
  bs_ = 0;
  clear_has_bs();
}
inline ::google::protobuf::int32 TradeResult::bs() const {
  return bs_;
}
inline void TradeResult::set_bs(::google::protobuf::int32 value) {
  set_has_bs();
  bs_ = value;
}

// required int64 start_time = 15;
inline bool TradeResult::has_start_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TradeResult::set_has_start_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TradeResult::clear_has_start_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TradeResult::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 TradeResult::start_time() const {
  return start_time_;
}
inline void TradeResult::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
}

// required int64 over_time = 16;
inline bool TradeResult::has_over_time() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TradeResult::set_has_over_time() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TradeResult::clear_has_over_time() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TradeResult::clear_over_time() {
  over_time_ = GOOGLE_LONGLONG(0);
  clear_has_over_time();
}
inline ::google::protobuf::int64 TradeResult::over_time() const {
  return over_time_;
}
inline void TradeResult::set_over_time(::google::protobuf::int64 value) {
  set_has_over_time();
  over_time_ = value;
}

// required int64 cost_time = 17;
inline bool TradeResult::has_cost_time() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TradeResult::set_has_cost_time() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TradeResult::clear_has_cost_time() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TradeResult::clear_cost_time() {
  cost_time_ = GOOGLE_LONGLONG(0);
  clear_has_cost_time();
}
inline ::google::protobuf::int64 TradeResult::cost_time() const {
  return cost_time_;
}
inline void TradeResult::set_cost_time(::google::protobuf::int64 value) {
  set_has_cost_time();
  cost_time_ = value;
}

// required string last_error = 18;
inline bool TradeResult::has_last_error() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TradeResult::set_has_last_error() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TradeResult::clear_has_last_error() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TradeResult::clear_last_error() {
  if (last_error_ != &::google::protobuf::internal::kEmptyString) {
    last_error_->clear();
  }
  clear_has_last_error();
}
inline const ::std::string& TradeResult::last_error() const {
  return *last_error_;
}
inline void TradeResult::set_last_error(const ::std::string& value) {
  set_has_last_error();
  if (last_error_ == &::google::protobuf::internal::kEmptyString) {
    last_error_ = new ::std::string;
  }
  last_error_->assign(value);
}
inline void TradeResult::set_last_error(const char* value) {
  set_has_last_error();
  if (last_error_ == &::google::protobuf::internal::kEmptyString) {
    last_error_ = new ::std::string;
  }
  last_error_->assign(value);
}
inline void TradeResult::set_last_error(const char* value, size_t size) {
  set_has_last_error();
  if (last_error_ == &::google::protobuf::internal::kEmptyString) {
    last_error_ = new ::std::string;
  }
  last_error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeResult::mutable_last_error() {
  set_has_last_error();
  if (last_error_ == &::google::protobuf::internal::kEmptyString) {
    last_error_ = new ::std::string;
  }
  return last_error_;
}
inline ::std::string* TradeResult::release_last_error() {
  clear_has_last_error();
  if (last_error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_error_;
    last_error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeResult::set_allocated_last_error(::std::string* last_error) {
  if (last_error_ != &::google::protobuf::internal::kEmptyString) {
    delete last_error_;
  }
  if (last_error) {
    set_has_last_error();
    last_error_ = last_error;
  } else {
    clear_has_last_error();
    last_error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 withdraw_times = 19;
inline bool TradeResult::has_withdraw_times() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TradeResult::set_has_withdraw_times() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TradeResult::clear_has_withdraw_times() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TradeResult::clear_withdraw_times() {
  withdraw_times_ = 0;
  clear_has_withdraw_times();
}
inline ::google::protobuf::int32 TradeResult::withdraw_times() const {
  return withdraw_times_;
}
inline void TradeResult::set_withdraw_times(::google::protobuf::int32 value) {
  set_has_withdraw_times();
  withdraw_times_ = value;
}

// required int32 level = 20;
inline bool TradeResult::has_level() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TradeResult::set_has_level() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TradeResult::clear_has_level() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TradeResult::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 TradeResult::level() const {
  return level_;
}
inline void TradeResult::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// LoginStatus

// required int64 time = 1;
inline bool LoginStatus::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginStatus::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginStatus::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginStatus::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 LoginStatus::time() const {
  return time_;
}
inline void LoginStatus::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required string time_string = 2;
inline bool LoginStatus::has_time_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginStatus::set_has_time_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginStatus::clear_has_time_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginStatus::clear_time_string() {
  if (time_string_ != &::google::protobuf::internal::kEmptyString) {
    time_string_->clear();
  }
  clear_has_time_string();
}
inline const ::std::string& LoginStatus::time_string() const {
  return *time_string_;
}
inline void LoginStatus::set_time_string(const ::std::string& value) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(value);
}
inline void LoginStatus::set_time_string(const char* value) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(value);
}
inline void LoginStatus::set_time_string(const char* value, size_t size) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginStatus::mutable_time_string() {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  return time_string_;
}
inline ::std::string* LoginStatus::release_time_string() {
  clear_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_string_;
    time_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginStatus::set_allocated_time_string(::std::string* time_string) {
  if (time_string_ != &::google::protobuf::internal::kEmptyString) {
    delete time_string_;
  }
  if (time_string) {
    set_has_time_string();
    time_string_ = time_string;
  } else {
    clear_has_time_string();
    time_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user = 3;
inline bool LoginStatus::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginStatus::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginStatus::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginStatus::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& LoginStatus::user() const {
  return *user_;
}
inline void LoginStatus::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void LoginStatus::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void LoginStatus::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginStatus::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* LoginStatus::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginStatus::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 error_id = 4;
inline bool LoginStatus::has_error_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginStatus::set_has_error_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginStatus::clear_has_error_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginStatus::clear_error_id() {
  error_id_ = 0;
  clear_has_error_id();
}
inline ::google::protobuf::int32 LoginStatus::error_id() const {
  return error_id_;
}
inline void LoginStatus::set_error_id(::google::protobuf::int32 value) {
  set_has_error_id();
  error_id_ = value;
}

// required string error_msg = 5;
inline bool LoginStatus::has_error_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginStatus::set_has_error_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginStatus::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginStatus::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& LoginStatus::error_msg() const {
  return *error_msg_;
}
inline void LoginStatus::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void LoginStatus::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void LoginStatus::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginStatus::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* LoginStatus::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginStatus::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete error_msg_;
  }
  if (error_msg) {
    set_has_error_msg();
    error_msg_ = error_msg;
  } else {
    clear_has_error_msg();
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ip = 6;
inline bool LoginStatus::has_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginStatus::set_has_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginStatus::clear_has_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginStatus::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& LoginStatus::ip() const {
  return *ip_;
}
inline void LoginStatus::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void LoginStatus::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void LoginStatus::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginStatus::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* LoginStatus::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginStatus::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Position

// required int64 time = 1;
inline bool Position::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Position::time() const {
  return time_;
}
inline void Position::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required string time_string = 2;
inline bool Position::has_time_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_time_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_time_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_time_string() {
  if (time_string_ != &::google::protobuf::internal::kEmptyString) {
    time_string_->clear();
  }
  clear_has_time_string();
}
inline const ::std::string& Position::time_string() const {
  return *time_string_;
}
inline void Position::set_time_string(const ::std::string& value) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(value);
}
inline void Position::set_time_string(const char* value) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(value);
}
inline void Position::set_time_string(const char* value, size_t size) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Position::mutable_time_string() {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  return time_string_;
}
inline ::std::string* Position::release_time_string() {
  clear_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_string_;
    time_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Position::set_allocated_time_string(::std::string* time_string) {
  if (time_string_ != &::google::protobuf::internal::kEmptyString) {
    delete time_string_;
  }
  if (time_string) {
    set_has_time_string();
    time_string_ = time_string;
  } else {
    clear_has_time_string();
    time_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user = 3;
inline bool Position::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& Position::user() const {
  return *user_;
}
inline void Position::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Position::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Position::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Position::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* Position::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Position::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double price_index = 4;
inline bool Position::has_price_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Position::set_has_price_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Position::clear_has_price_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Position::clear_price_index() {
  price_index_ = 0;
  clear_has_price_index();
}
inline double Position::price_index() const {
  return price_index_;
}
inline void Position::set_price_index(double value) {
  set_has_price_index();
  price_index_ = value;
}

// required double stop_price = 5;
inline bool Position::has_stop_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Position::set_has_stop_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Position::clear_has_stop_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Position::clear_stop_price() {
  stop_price_ = 0;
  clear_has_stop_price();
}
inline double Position::stop_price() const {
  return stop_price_;
}
inline void Position::set_stop_price(double value) {
  set_has_stop_price();
  stop_price_ = value;
}

// required string instrumentid = 6;
inline bool Position::has_instrumentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Position::set_has_instrumentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Position::clear_has_instrumentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Position::clear_instrumentid() {
  if (instrumentid_ != &::google::protobuf::internal::kEmptyString) {
    instrumentid_->clear();
  }
  clear_has_instrumentid();
}
inline const ::std::string& Position::instrumentid() const {
  return *instrumentid_;
}
inline void Position::set_instrumentid(const ::std::string& value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void Position::set_instrumentid(const char* value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void Position::set_instrumentid(const char* value, size_t size) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Position::mutable_instrumentid() {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  return instrumentid_;
}
inline ::std::string* Position::release_instrumentid() {
  clear_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrumentid_;
    instrumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Position::set_allocated_instrumentid(::std::string* instrumentid) {
  if (instrumentid_ != &::google::protobuf::internal::kEmptyString) {
    delete instrumentid_;
  }
  if (instrumentid) {
    set_has_instrumentid();
    instrumentid_ = instrumentid;
  } else {
    clear_has_instrumentid();
    instrumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string brokerid = 7;
inline bool Position::has_brokerid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Position::set_has_brokerid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Position::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Position::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& Position::brokerid() const {
  return *brokerid_;
}
inline void Position::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void Position::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void Position::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Position::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* Position::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Position::set_allocated_brokerid(::std::string* brokerid) {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    delete brokerid_;
  }
  if (brokerid) {
    set_has_brokerid();
    brokerid_ = brokerid;
  } else {
    clear_has_brokerid();
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string investorid = 8;
inline bool Position::has_investorid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Position::set_has_investorid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Position::clear_has_investorid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Position::clear_investorid() {
  if (investorid_ != &::google::protobuf::internal::kEmptyString) {
    investorid_->clear();
  }
  clear_has_investorid();
}
inline const ::std::string& Position::investorid() const {
  return *investorid_;
}
inline void Position::set_investorid(const ::std::string& value) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(value);
}
inline void Position::set_investorid(const char* value) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(value);
}
inline void Position::set_investorid(const char* value, size_t size) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Position::mutable_investorid() {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  return investorid_;
}
inline ::std::string* Position::release_investorid() {
  clear_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investorid_;
    investorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Position::set_allocated_investorid(::std::string* investorid) {
  if (investorid_ != &::google::protobuf::internal::kEmptyString) {
    delete investorid_;
  }
  if (investorid) {
    set_has_investorid();
    investorid_ = investorid;
  } else {
    clear_has_investorid();
    investorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 posidirection = 9;
inline bool Position::has_posidirection() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Position::set_has_posidirection() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Position::clear_has_posidirection() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Position::clear_posidirection() {
  posidirection_ = 0;
  clear_has_posidirection();
}
inline ::google::protobuf::int32 Position::posidirection() const {
  return posidirection_;
}
inline void Position::set_posidirection(::google::protobuf::int32 value) {
  set_has_posidirection();
  posidirection_ = value;
}

// required int32 hedgeflag = 10;
inline bool Position::has_hedgeflag() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Position::set_has_hedgeflag() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Position::clear_has_hedgeflag() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Position::clear_hedgeflag() {
  hedgeflag_ = 0;
  clear_has_hedgeflag();
}
inline ::google::protobuf::int32 Position::hedgeflag() const {
  return hedgeflag_;
}
inline void Position::set_hedgeflag(::google::protobuf::int32 value) {
  set_has_hedgeflag();
  hedgeflag_ = value;
}

// required int32 positiondate = 11;
inline bool Position::has_positiondate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Position::set_has_positiondate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Position::clear_has_positiondate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Position::clear_positiondate() {
  positiondate_ = 0;
  clear_has_positiondate();
}
inline ::google::protobuf::int32 Position::positiondate() const {
  return positiondate_;
}
inline void Position::set_positiondate(::google::protobuf::int32 value) {
  set_has_positiondate();
  positiondate_ = value;
}

// required int32 ydposition = 12;
inline bool Position::has_ydposition() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Position::set_has_ydposition() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Position::clear_has_ydposition() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Position::clear_ydposition() {
  ydposition_ = 0;
  clear_has_ydposition();
}
inline ::google::protobuf::int32 Position::ydposition() const {
  return ydposition_;
}
inline void Position::set_ydposition(::google::protobuf::int32 value) {
  set_has_ydposition();
  ydposition_ = value;
}

// required int32 position = 13;
inline bool Position::has_position() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Position::set_has_position() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Position::clear_has_position() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Position::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 Position::position() const {
  return position_;
}
inline void Position::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
}

// required int32 longfrozen = 14;
inline bool Position::has_longfrozen() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Position::set_has_longfrozen() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Position::clear_has_longfrozen() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Position::clear_longfrozen() {
  longfrozen_ = 0;
  clear_has_longfrozen();
}
inline ::google::protobuf::int32 Position::longfrozen() const {
  return longfrozen_;
}
inline void Position::set_longfrozen(::google::protobuf::int32 value) {
  set_has_longfrozen();
  longfrozen_ = value;
}

// required int32 shortfrozen = 15;
inline bool Position::has_shortfrozen() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Position::set_has_shortfrozen() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Position::clear_has_shortfrozen() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Position::clear_shortfrozen() {
  shortfrozen_ = 0;
  clear_has_shortfrozen();
}
inline ::google::protobuf::int32 Position::shortfrozen() const {
  return shortfrozen_;
}
inline void Position::set_shortfrozen(::google::protobuf::int32 value) {
  set_has_shortfrozen();
  shortfrozen_ = value;
}

// required double longfrozenamount = 16;
inline bool Position::has_longfrozenamount() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Position::set_has_longfrozenamount() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Position::clear_has_longfrozenamount() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Position::clear_longfrozenamount() {
  longfrozenamount_ = 0;
  clear_has_longfrozenamount();
}
inline double Position::longfrozenamount() const {
  return longfrozenamount_;
}
inline void Position::set_longfrozenamount(double value) {
  set_has_longfrozenamount();
  longfrozenamount_ = value;
}

// required double shortfrozenamount = 17;
inline bool Position::has_shortfrozenamount() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Position::set_has_shortfrozenamount() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Position::clear_has_shortfrozenamount() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Position::clear_shortfrozenamount() {
  shortfrozenamount_ = 0;
  clear_has_shortfrozenamount();
}
inline double Position::shortfrozenamount() const {
  return shortfrozenamount_;
}
inline void Position::set_shortfrozenamount(double value) {
  set_has_shortfrozenamount();
  shortfrozenamount_ = value;
}

// required int32 openvolume = 18;
inline bool Position::has_openvolume() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Position::set_has_openvolume() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Position::clear_has_openvolume() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Position::clear_openvolume() {
  openvolume_ = 0;
  clear_has_openvolume();
}
inline ::google::protobuf::int32 Position::openvolume() const {
  return openvolume_;
}
inline void Position::set_openvolume(::google::protobuf::int32 value) {
  set_has_openvolume();
  openvolume_ = value;
}

// required int32 closevolume = 19;
inline bool Position::has_closevolume() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Position::set_has_closevolume() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Position::clear_has_closevolume() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Position::clear_closevolume() {
  closevolume_ = 0;
  clear_has_closevolume();
}
inline ::google::protobuf::int32 Position::closevolume() const {
  return closevolume_;
}
inline void Position::set_closevolume(::google::protobuf::int32 value) {
  set_has_closevolume();
  closevolume_ = value;
}

// required double openamount = 20;
inline bool Position::has_openamount() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Position::set_has_openamount() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Position::clear_has_openamount() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Position::clear_openamount() {
  openamount_ = 0;
  clear_has_openamount();
}
inline double Position::openamount() const {
  return openamount_;
}
inline void Position::set_openamount(double value) {
  set_has_openamount();
  openamount_ = value;
}

// required double closeamount = 21;
inline bool Position::has_closeamount() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Position::set_has_closeamount() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Position::clear_has_closeamount() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Position::clear_closeamount() {
  closeamount_ = 0;
  clear_has_closeamount();
}
inline double Position::closeamount() const {
  return closeamount_;
}
inline void Position::set_closeamount(double value) {
  set_has_closeamount();
  closeamount_ = value;
}

// required double positioncost = 22;
inline bool Position::has_positioncost() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Position::set_has_positioncost() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Position::clear_has_positioncost() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Position::clear_positioncost() {
  positioncost_ = 0;
  clear_has_positioncost();
}
inline double Position::positioncost() const {
  return positioncost_;
}
inline void Position::set_positioncost(double value) {
  set_has_positioncost();
  positioncost_ = value;
}

// required double premargin = 23;
inline bool Position::has_premargin() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Position::set_has_premargin() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Position::clear_has_premargin() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Position::clear_premargin() {
  premargin_ = 0;
  clear_has_premargin();
}
inline double Position::premargin() const {
  return premargin_;
}
inline void Position::set_premargin(double value) {
  set_has_premargin();
  premargin_ = value;
}

// required double usemargin = 24;
inline bool Position::has_usemargin() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Position::set_has_usemargin() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Position::clear_has_usemargin() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Position::clear_usemargin() {
  usemargin_ = 0;
  clear_has_usemargin();
}
inline double Position::usemargin() const {
  return usemargin_;
}
inline void Position::set_usemargin(double value) {
  set_has_usemargin();
  usemargin_ = value;
}

// required double frozenmargin = 25;
inline bool Position::has_frozenmargin() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Position::set_has_frozenmargin() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Position::clear_has_frozenmargin() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Position::clear_frozenmargin() {
  frozenmargin_ = 0;
  clear_has_frozenmargin();
}
inline double Position::frozenmargin() const {
  return frozenmargin_;
}
inline void Position::set_frozenmargin(double value) {
  set_has_frozenmargin();
  frozenmargin_ = value;
}

// required double frozencash = 26;
inline bool Position::has_frozencash() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Position::set_has_frozencash() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Position::clear_has_frozencash() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Position::clear_frozencash() {
  frozencash_ = 0;
  clear_has_frozencash();
}
inline double Position::frozencash() const {
  return frozencash_;
}
inline void Position::set_frozencash(double value) {
  set_has_frozencash();
  frozencash_ = value;
}

// required double frozencommission = 27;
inline bool Position::has_frozencommission() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Position::set_has_frozencommission() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Position::clear_has_frozencommission() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Position::clear_frozencommission() {
  frozencommission_ = 0;
  clear_has_frozencommission();
}
inline double Position::frozencommission() const {
  return frozencommission_;
}
inline void Position::set_frozencommission(double value) {
  set_has_frozencommission();
  frozencommission_ = value;
}

// required double cashin = 28;
inline bool Position::has_cashin() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Position::set_has_cashin() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Position::clear_has_cashin() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Position::clear_cashin() {
  cashin_ = 0;
  clear_has_cashin();
}
inline double Position::cashin() const {
  return cashin_;
}
inline void Position::set_cashin(double value) {
  set_has_cashin();
  cashin_ = value;
}

// required double commission = 29;
inline bool Position::has_commission() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Position::set_has_commission() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Position::clear_has_commission() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Position::clear_commission() {
  commission_ = 0;
  clear_has_commission();
}
inline double Position::commission() const {
  return commission_;
}
inline void Position::set_commission(double value) {
  set_has_commission();
  commission_ = value;
}

// required double closeprofit = 30;
inline bool Position::has_closeprofit() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Position::set_has_closeprofit() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Position::clear_has_closeprofit() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Position::clear_closeprofit() {
  closeprofit_ = 0;
  clear_has_closeprofit();
}
inline double Position::closeprofit() const {
  return closeprofit_;
}
inline void Position::set_closeprofit(double value) {
  set_has_closeprofit();
  closeprofit_ = value;
}

// required double positionprofit = 31;
inline bool Position::has_positionprofit() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Position::set_has_positionprofit() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Position::clear_has_positionprofit() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Position::clear_positionprofit() {
  positionprofit_ = 0;
  clear_has_positionprofit();
}
inline double Position::positionprofit() const {
  return positionprofit_;
}
inline void Position::set_positionprofit(double value) {
  set_has_positionprofit();
  positionprofit_ = value;
}

// required double presettlementprice = 32;
inline bool Position::has_presettlementprice() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Position::set_has_presettlementprice() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Position::clear_has_presettlementprice() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Position::clear_presettlementprice() {
  presettlementprice_ = 0;
  clear_has_presettlementprice();
}
inline double Position::presettlementprice() const {
  return presettlementprice_;
}
inline void Position::set_presettlementprice(double value) {
  set_has_presettlementprice();
  presettlementprice_ = value;
}

// required double settlementprice = 33;
inline bool Position::has_settlementprice() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Position::set_has_settlementprice() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Position::clear_has_settlementprice() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Position::clear_settlementprice() {
  settlementprice_ = 0;
  clear_has_settlementprice();
}
inline double Position::settlementprice() const {
  return settlementprice_;
}
inline void Position::set_settlementprice(double value) {
  set_has_settlementprice();
  settlementprice_ = value;
}

// required string tradingday = 34;
inline bool Position::has_tradingday() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Position::set_has_tradingday() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Position::clear_has_tradingday() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Position::clear_tradingday() {
  if (tradingday_ != &::google::protobuf::internal::kEmptyString) {
    tradingday_->clear();
  }
  clear_has_tradingday();
}
inline const ::std::string& Position::tradingday() const {
  return *tradingday_;
}
inline void Position::set_tradingday(const ::std::string& value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void Position::set_tradingday(const char* value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void Position::set_tradingday(const char* value, size_t size) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Position::mutable_tradingday() {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  return tradingday_;
}
inline ::std::string* Position::release_tradingday() {
  clear_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradingday_;
    tradingday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Position::set_allocated_tradingday(::std::string* tradingday) {
  if (tradingday_ != &::google::protobuf::internal::kEmptyString) {
    delete tradingday_;
  }
  if (tradingday) {
    set_has_tradingday();
    tradingday_ = tradingday;
  } else {
    clear_has_tradingday();
    tradingday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 settlementid = 35;
inline bool Position::has_settlementid() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Position::set_has_settlementid() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Position::clear_has_settlementid() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Position::clear_settlementid() {
  settlementid_ = 0;
  clear_has_settlementid();
}
inline ::google::protobuf::int32 Position::settlementid() const {
  return settlementid_;
}
inline void Position::set_settlementid(::google::protobuf::int32 value) {
  set_has_settlementid();
  settlementid_ = value;
}

// required double opencost = 36;
inline bool Position::has_opencost() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Position::set_has_opencost() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Position::clear_has_opencost() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Position::clear_opencost() {
  opencost_ = 0;
  clear_has_opencost();
}
inline double Position::opencost() const {
  return opencost_;
}
inline void Position::set_opencost(double value) {
  set_has_opencost();
  opencost_ = value;
}

// required double exchangemargin = 37;
inline bool Position::has_exchangemargin() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Position::set_has_exchangemargin() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Position::clear_has_exchangemargin() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Position::clear_exchangemargin() {
  exchangemargin_ = 0;
  clear_has_exchangemargin();
}
inline double Position::exchangemargin() const {
  return exchangemargin_;
}
inline void Position::set_exchangemargin(double value) {
  set_has_exchangemargin();
  exchangemargin_ = value;
}

// required int32 combposition = 38;
inline bool Position::has_combposition() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Position::set_has_combposition() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Position::clear_has_combposition() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Position::clear_combposition() {
  combposition_ = 0;
  clear_has_combposition();
}
inline ::google::protobuf::int32 Position::combposition() const {
  return combposition_;
}
inline void Position::set_combposition(::google::protobuf::int32 value) {
  set_has_combposition();
  combposition_ = value;
}

// required int32 comblongfrozen = 39;
inline bool Position::has_comblongfrozen() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Position::set_has_comblongfrozen() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Position::clear_has_comblongfrozen() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Position::clear_comblongfrozen() {
  comblongfrozen_ = 0;
  clear_has_comblongfrozen();
}
inline ::google::protobuf::int32 Position::comblongfrozen() const {
  return comblongfrozen_;
}
inline void Position::set_comblongfrozen(::google::protobuf::int32 value) {
  set_has_comblongfrozen();
  comblongfrozen_ = value;
}

// required int32 combshortfrozen = 40;
inline bool Position::has_combshortfrozen() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Position::set_has_combshortfrozen() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Position::clear_has_combshortfrozen() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Position::clear_combshortfrozen() {
  combshortfrozen_ = 0;
  clear_has_combshortfrozen();
}
inline ::google::protobuf::int32 Position::combshortfrozen() const {
  return combshortfrozen_;
}
inline void Position::set_combshortfrozen(::google::protobuf::int32 value) {
  set_has_combshortfrozen();
  combshortfrozen_ = value;
}

// required double closeprofitbydate = 41;
inline bool Position::has_closeprofitbydate() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Position::set_has_closeprofitbydate() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Position::clear_has_closeprofitbydate() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void Position::clear_closeprofitbydate() {
  closeprofitbydate_ = 0;
  clear_has_closeprofitbydate();
}
inline double Position::closeprofitbydate() const {
  return closeprofitbydate_;
}
inline void Position::set_closeprofitbydate(double value) {
  set_has_closeprofitbydate();
  closeprofitbydate_ = value;
}

// required double closeprofitbytrade = 42;
inline bool Position::has_closeprofitbytrade() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void Position::set_has_closeprofitbytrade() {
  _has_bits_[1] |= 0x00000200u;
}
inline void Position::clear_has_closeprofitbytrade() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void Position::clear_closeprofitbytrade() {
  closeprofitbytrade_ = 0;
  clear_has_closeprofitbytrade();
}
inline double Position::closeprofitbytrade() const {
  return closeprofitbytrade_;
}
inline void Position::set_closeprofitbytrade(double value) {
  set_has_closeprofitbytrade();
  closeprofitbytrade_ = value;
}

// required int32 todayposition = 43;
inline bool Position::has_todayposition() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void Position::set_has_todayposition() {
  _has_bits_[1] |= 0x00000400u;
}
inline void Position::clear_has_todayposition() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void Position::clear_todayposition() {
  todayposition_ = 0;
  clear_has_todayposition();
}
inline ::google::protobuf::int32 Position::todayposition() const {
  return todayposition_;
}
inline void Position::set_todayposition(::google::protobuf::int32 value) {
  set_has_todayposition();
  todayposition_ = value;
}

// required double marginratebymoney = 44;
inline bool Position::has_marginratebymoney() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void Position::set_has_marginratebymoney() {
  _has_bits_[1] |= 0x00000800u;
}
inline void Position::clear_has_marginratebymoney() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void Position::clear_marginratebymoney() {
  marginratebymoney_ = 0;
  clear_has_marginratebymoney();
}
inline double Position::marginratebymoney() const {
  return marginratebymoney_;
}
inline void Position::set_marginratebymoney(double value) {
  set_has_marginratebymoney();
  marginratebymoney_ = value;
}

// required double marginratebyvolume = 45;
inline bool Position::has_marginratebyvolume() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void Position::set_has_marginratebyvolume() {
  _has_bits_[1] |= 0x00001000u;
}
inline void Position::clear_has_marginratebyvolume() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void Position::clear_marginratebyvolume() {
  marginratebyvolume_ = 0;
  clear_has_marginratebyvolume();
}
inline double Position::marginratebyvolume() const {
  return marginratebyvolume_;
}
inline void Position::set_marginratebyvolume(double value) {
  set_has_marginratebyvolume();
  marginratebyvolume_ = value;
}

// -------------------------------------------------------------------

// Account

// required int64 time = 1;
inline bool Account::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Account::time() const {
  return time_;
}
inline void Account::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required string time_string = 2;
inline bool Account::has_time_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account::set_has_time_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account::clear_has_time_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account::clear_time_string() {
  if (time_string_ != &::google::protobuf::internal::kEmptyString) {
    time_string_->clear();
  }
  clear_has_time_string();
}
inline const ::std::string& Account::time_string() const {
  return *time_string_;
}
inline void Account::set_time_string(const ::std::string& value) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(value);
}
inline void Account::set_time_string(const char* value) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(value);
}
inline void Account::set_time_string(const char* value, size_t size) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_time_string() {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  return time_string_;
}
inline ::std::string* Account::release_time_string() {
  clear_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_string_;
    time_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Account::set_allocated_time_string(::std::string* time_string) {
  if (time_string_ != &::google::protobuf::internal::kEmptyString) {
    delete time_string_;
  }
  if (time_string) {
    set_has_time_string();
    time_string_ = time_string;
  } else {
    clear_has_time_string();
    time_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string user = 3;
inline bool Account::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Account::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Account::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Account::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& Account::user() const {
  return *user_;
}
inline void Account::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Account::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void Account::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* Account::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Account::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string brokerid = 4;
inline bool Account::has_brokerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Account::set_has_brokerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Account::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Account::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& Account::brokerid() const {
  return *brokerid_;
}
inline void Account::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void Account::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void Account::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* Account::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Account::set_allocated_brokerid(::std::string* brokerid) {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    delete brokerid_;
  }
  if (brokerid) {
    set_has_brokerid();
    brokerid_ = brokerid;
  } else {
    clear_has_brokerid();
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string accountid = 5;
inline bool Account::has_accountid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Account::set_has_accountid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Account::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Account::clear_accountid() {
  if (accountid_ != &::google::protobuf::internal::kEmptyString) {
    accountid_->clear();
  }
  clear_has_accountid();
}
inline const ::std::string& Account::accountid() const {
  return *accountid_;
}
inline void Account::set_accountid(const ::std::string& value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void Account::set_accountid(const char* value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void Account::set_accountid(const char* value, size_t size) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_accountid() {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  return accountid_;
}
inline ::std::string* Account::release_accountid() {
  clear_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountid_;
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Account::set_allocated_accountid(::std::string* accountid) {
  if (accountid_ != &::google::protobuf::internal::kEmptyString) {
    delete accountid_;
  }
  if (accountid) {
    set_has_accountid();
    accountid_ = accountid;
  } else {
    clear_has_accountid();
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double premortgage = 6;
inline bool Account::has_premortgage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Account::set_has_premortgage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Account::clear_has_premortgage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Account::clear_premortgage() {
  premortgage_ = 0;
  clear_has_premortgage();
}
inline double Account::premortgage() const {
  return premortgage_;
}
inline void Account::set_premortgage(double value) {
  set_has_premortgage();
  premortgage_ = value;
}

// required double precredit = 7;
inline bool Account::has_precredit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Account::set_has_precredit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Account::clear_has_precredit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Account::clear_precredit() {
  precredit_ = 0;
  clear_has_precredit();
}
inline double Account::precredit() const {
  return precredit_;
}
inline void Account::set_precredit(double value) {
  set_has_precredit();
  precredit_ = value;
}

// required double predeposit = 8;
inline bool Account::has_predeposit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Account::set_has_predeposit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Account::clear_has_predeposit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Account::clear_predeposit() {
  predeposit_ = 0;
  clear_has_predeposit();
}
inline double Account::predeposit() const {
  return predeposit_;
}
inline void Account::set_predeposit(double value) {
  set_has_predeposit();
  predeposit_ = value;
}

// required double prebalance = 9;
inline bool Account::has_prebalance() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Account::set_has_prebalance() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Account::clear_has_prebalance() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Account::clear_prebalance() {
  prebalance_ = 0;
  clear_has_prebalance();
}
inline double Account::prebalance() const {
  return prebalance_;
}
inline void Account::set_prebalance(double value) {
  set_has_prebalance();
  prebalance_ = value;
}

// required double premargin = 10;
inline bool Account::has_premargin() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Account::set_has_premargin() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Account::clear_has_premargin() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Account::clear_premargin() {
  premargin_ = 0;
  clear_has_premargin();
}
inline double Account::premargin() const {
  return premargin_;
}
inline void Account::set_premargin(double value) {
  set_has_premargin();
  premargin_ = value;
}

// required double interestbase = 11;
inline bool Account::has_interestbase() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Account::set_has_interestbase() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Account::clear_has_interestbase() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Account::clear_interestbase() {
  interestbase_ = 0;
  clear_has_interestbase();
}
inline double Account::interestbase() const {
  return interestbase_;
}
inline void Account::set_interestbase(double value) {
  set_has_interestbase();
  interestbase_ = value;
}

// required double interest = 12;
inline bool Account::has_interest() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Account::set_has_interest() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Account::clear_has_interest() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Account::clear_interest() {
  interest_ = 0;
  clear_has_interest();
}
inline double Account::interest() const {
  return interest_;
}
inline void Account::set_interest(double value) {
  set_has_interest();
  interest_ = value;
}

// required double deposit = 13;
inline bool Account::has_deposit() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Account::set_has_deposit() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Account::clear_has_deposit() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Account::clear_deposit() {
  deposit_ = 0;
  clear_has_deposit();
}
inline double Account::deposit() const {
  return deposit_;
}
inline void Account::set_deposit(double value) {
  set_has_deposit();
  deposit_ = value;
}

// required double withdraw = 14;
inline bool Account::has_withdraw() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Account::set_has_withdraw() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Account::clear_has_withdraw() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Account::clear_withdraw() {
  withdraw_ = 0;
  clear_has_withdraw();
}
inline double Account::withdraw() const {
  return withdraw_;
}
inline void Account::set_withdraw(double value) {
  set_has_withdraw();
  withdraw_ = value;
}

// required double frozenmargin = 15;
inline bool Account::has_frozenmargin() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Account::set_has_frozenmargin() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Account::clear_has_frozenmargin() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Account::clear_frozenmargin() {
  frozenmargin_ = 0;
  clear_has_frozenmargin();
}
inline double Account::frozenmargin() const {
  return frozenmargin_;
}
inline void Account::set_frozenmargin(double value) {
  set_has_frozenmargin();
  frozenmargin_ = value;
}

// required double frozencash = 16;
inline bool Account::has_frozencash() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Account::set_has_frozencash() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Account::clear_has_frozencash() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Account::clear_frozencash() {
  frozencash_ = 0;
  clear_has_frozencash();
}
inline double Account::frozencash() const {
  return frozencash_;
}
inline void Account::set_frozencash(double value) {
  set_has_frozencash();
  frozencash_ = value;
}

// required double frozencommission = 17;
inline bool Account::has_frozencommission() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Account::set_has_frozencommission() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Account::clear_has_frozencommission() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Account::clear_frozencommission() {
  frozencommission_ = 0;
  clear_has_frozencommission();
}
inline double Account::frozencommission() const {
  return frozencommission_;
}
inline void Account::set_frozencommission(double value) {
  set_has_frozencommission();
  frozencommission_ = value;
}

// required double currmargin = 18;
inline bool Account::has_currmargin() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Account::set_has_currmargin() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Account::clear_has_currmargin() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Account::clear_currmargin() {
  currmargin_ = 0;
  clear_has_currmargin();
}
inline double Account::currmargin() const {
  return currmargin_;
}
inline void Account::set_currmargin(double value) {
  set_has_currmargin();
  currmargin_ = value;
}

// required double cashin = 19;
inline bool Account::has_cashin() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Account::set_has_cashin() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Account::clear_has_cashin() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Account::clear_cashin() {
  cashin_ = 0;
  clear_has_cashin();
}
inline double Account::cashin() const {
  return cashin_;
}
inline void Account::set_cashin(double value) {
  set_has_cashin();
  cashin_ = value;
}

// required double commission = 20;
inline bool Account::has_commission() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Account::set_has_commission() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Account::clear_has_commission() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Account::clear_commission() {
  commission_ = 0;
  clear_has_commission();
}
inline double Account::commission() const {
  return commission_;
}
inline void Account::set_commission(double value) {
  set_has_commission();
  commission_ = value;
}

// required double closeprofit = 21;
inline bool Account::has_closeprofit() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Account::set_has_closeprofit() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Account::clear_has_closeprofit() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Account::clear_closeprofit() {
  closeprofit_ = 0;
  clear_has_closeprofit();
}
inline double Account::closeprofit() const {
  return closeprofit_;
}
inline void Account::set_closeprofit(double value) {
  set_has_closeprofit();
  closeprofit_ = value;
}

// required double positionprofit = 22;
inline bool Account::has_positionprofit() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Account::set_has_positionprofit() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Account::clear_has_positionprofit() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Account::clear_positionprofit() {
  positionprofit_ = 0;
  clear_has_positionprofit();
}
inline double Account::positionprofit() const {
  return positionprofit_;
}
inline void Account::set_positionprofit(double value) {
  set_has_positionprofit();
  positionprofit_ = value;
}

// required double balance = 23;
inline bool Account::has_balance() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Account::set_has_balance() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Account::clear_has_balance() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Account::clear_balance() {
  balance_ = 0;
  clear_has_balance();
}
inline double Account::balance() const {
  return balance_;
}
inline void Account::set_balance(double value) {
  set_has_balance();
  balance_ = value;
}

// required double available = 24;
inline bool Account::has_available() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Account::set_has_available() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Account::clear_has_available() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Account::clear_available() {
  available_ = 0;
  clear_has_available();
}
inline double Account::available() const {
  return available_;
}
inline void Account::set_available(double value) {
  set_has_available();
  available_ = value;
}

// required double withdrawquota = 25;
inline bool Account::has_withdrawquota() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Account::set_has_withdrawquota() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Account::clear_has_withdrawquota() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Account::clear_withdrawquota() {
  withdrawquota_ = 0;
  clear_has_withdrawquota();
}
inline double Account::withdrawquota() const {
  return withdrawquota_;
}
inline void Account::set_withdrawquota(double value) {
  set_has_withdrawquota();
  withdrawquota_ = value;
}

// required double reserve = 26;
inline bool Account::has_reserve() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Account::set_has_reserve() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Account::clear_has_reserve() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Account::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline double Account::reserve() const {
  return reserve_;
}
inline void Account::set_reserve(double value) {
  set_has_reserve();
  reserve_ = value;
}

// required string tradingday = 27;
inline bool Account::has_tradingday() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Account::set_has_tradingday() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Account::clear_has_tradingday() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Account::clear_tradingday() {
  if (tradingday_ != &::google::protobuf::internal::kEmptyString) {
    tradingday_->clear();
  }
  clear_has_tradingday();
}
inline const ::std::string& Account::tradingday() const {
  return *tradingday_;
}
inline void Account::set_tradingday(const ::std::string& value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void Account::set_tradingday(const char* value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void Account::set_tradingday(const char* value, size_t size) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_tradingday() {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  return tradingday_;
}
inline ::std::string* Account::release_tradingday() {
  clear_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradingday_;
    tradingday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Account::set_allocated_tradingday(::std::string* tradingday) {
  if (tradingday_ != &::google::protobuf::internal::kEmptyString) {
    delete tradingday_;
  }
  if (tradingday) {
    set_has_tradingday();
    tradingday_ = tradingday;
  } else {
    clear_has_tradingday();
    tradingday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 settlementid = 28;
inline bool Account::has_settlementid() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Account::set_has_settlementid() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Account::clear_has_settlementid() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Account::clear_settlementid() {
  settlementid_ = 0;
  clear_has_settlementid();
}
inline ::google::protobuf::int32 Account::settlementid() const {
  return settlementid_;
}
inline void Account::set_settlementid(::google::protobuf::int32 value) {
  set_has_settlementid();
  settlementid_ = value;
}

// required double credit = 29;
inline bool Account::has_credit() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Account::set_has_credit() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Account::clear_has_credit() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Account::clear_credit() {
  credit_ = 0;
  clear_has_credit();
}
inline double Account::credit() const {
  return credit_;
}
inline void Account::set_credit(double value) {
  set_has_credit();
  credit_ = value;
}

// required double mortgage = 30;
inline bool Account::has_mortgage() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Account::set_has_mortgage() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Account::clear_has_mortgage() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Account::clear_mortgage() {
  mortgage_ = 0;
  clear_has_mortgage();
}
inline double Account::mortgage() const {
  return mortgage_;
}
inline void Account::set_mortgage(double value) {
  set_has_mortgage();
  mortgage_ = value;
}

// required double exchangemargin = 31;
inline bool Account::has_exchangemargin() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Account::set_has_exchangemargin() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Account::clear_has_exchangemargin() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Account::clear_exchangemargin() {
  exchangemargin_ = 0;
  clear_has_exchangemargin();
}
inline double Account::exchangemargin() const {
  return exchangemargin_;
}
inline void Account::set_exchangemargin(double value) {
  set_has_exchangemargin();
  exchangemargin_ = value;
}

// -------------------------------------------------------------------

// BacktestingExpectAssetList

// required string table_name = 1;
inline bool BacktestingExpectAssetList::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BacktestingExpectAssetList::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BacktestingExpectAssetList::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BacktestingExpectAssetList::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& BacktestingExpectAssetList::table_name() const {
  return *table_name_;
}
inline void BacktestingExpectAssetList::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void BacktestingExpectAssetList::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void BacktestingExpectAssetList::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BacktestingExpectAssetList::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* BacktestingExpectAssetList::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BacktestingExpectAssetList::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string type = 2;
inline bool BacktestingExpectAssetList::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BacktestingExpectAssetList::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BacktestingExpectAssetList::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BacktestingExpectAssetList::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& BacktestingExpectAssetList::type() const {
  return *type_;
}
inline void BacktestingExpectAssetList::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void BacktestingExpectAssetList::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void BacktestingExpectAssetList::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BacktestingExpectAssetList::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* BacktestingExpectAssetList::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BacktestingExpectAssetList::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 3;
inline bool BacktestingExpectAssetList::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BacktestingExpectAssetList::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BacktestingExpectAssetList::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BacktestingExpectAssetList::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 BacktestingExpectAssetList::level() const {
  return level_;
}
inline void BacktestingExpectAssetList::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 total = 4;
inline bool BacktestingExpectAssetList::has_total() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BacktestingExpectAssetList::set_has_total() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BacktestingExpectAssetList::clear_has_total() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BacktestingExpectAssetList::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 BacktestingExpectAssetList::total() const {
  return total_;
}
inline void BacktestingExpectAssetList::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// repeated double data = 5;
inline int BacktestingExpectAssetList::data_size() const {
  return data_.size();
}
inline void BacktestingExpectAssetList::clear_data() {
  data_.Clear();
}
inline double BacktestingExpectAssetList::data(int index) const {
  return data_.Get(index);
}
inline void BacktestingExpectAssetList::set_data(int index, double value) {
  data_.Set(index, value);
}
inline void BacktestingExpectAssetList::add_data(double value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
BacktestingExpectAssetList::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< double >*
BacktestingExpectAssetList::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// BacktestingExpectAssetQuery

// required string table_name = 1;
inline bool BacktestingExpectAssetQuery::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BacktestingExpectAssetQuery::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BacktestingExpectAssetQuery::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BacktestingExpectAssetQuery::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& BacktestingExpectAssetQuery::table_name() const {
  return *table_name_;
}
inline void BacktestingExpectAssetQuery::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void BacktestingExpectAssetQuery::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void BacktestingExpectAssetQuery::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BacktestingExpectAssetQuery::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* BacktestingExpectAssetQuery::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BacktestingExpectAssetQuery::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string type = 2;
inline bool BacktestingExpectAssetQuery::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BacktestingExpectAssetQuery::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BacktestingExpectAssetQuery::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BacktestingExpectAssetQuery::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& BacktestingExpectAssetQuery::type() const {
  return *type_;
}
inline void BacktestingExpectAssetQuery::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void BacktestingExpectAssetQuery::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void BacktestingExpectAssetQuery::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BacktestingExpectAssetQuery::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* BacktestingExpectAssetQuery::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BacktestingExpectAssetQuery::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level = 3;
inline bool BacktestingExpectAssetQuery::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BacktestingExpectAssetQuery::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BacktestingExpectAssetQuery::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BacktestingExpectAssetQuery::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 BacktestingExpectAssetQuery::level() const {
  return level_;
}
inline void BacktestingExpectAssetQuery::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// BacktestingResultSave2DBRequery_BacktestingResultItem

// required string time_string = 1;
inline bool BacktestingResultSave2DBRequery_BacktestingResultItem::has_time_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::set_has_time_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::clear_has_time_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::clear_time_string() {
  if (time_string_ != &::google::protobuf::internal::kEmptyString) {
    time_string_->clear();
  }
  clear_has_time_string();
}
inline const ::std::string& BacktestingResultSave2DBRequery_BacktestingResultItem::time_string() const {
  return *time_string_;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::set_time_string(const ::std::string& value) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(value);
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::set_time_string(const char* value) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(value);
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::set_time_string(const char* value, size_t size) {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  time_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BacktestingResultSave2DBRequery_BacktestingResultItem::mutable_time_string() {
  set_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    time_string_ = new ::std::string;
  }
  return time_string_;
}
inline ::std::string* BacktestingResultSave2DBRequery_BacktestingResultItem::release_time_string() {
  clear_has_time_string();
  if (time_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_string_;
    time_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::set_allocated_time_string(::std::string* time_string) {
  if (time_string_ != &::google::protobuf::internal::kEmptyString) {
    delete time_string_;
  }
  if (time_string) {
    set_has_time_string();
    time_string_ = time_string;
  } else {
    clear_has_time_string();
    time_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 time = 2;
inline bool BacktestingResultSave2DBRequery_BacktestingResultItem::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 BacktestingResultSave2DBRequery_BacktestingResultItem::time() const {
  return time_;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required double money = 3;
inline bool BacktestingResultSave2DBRequery_BacktestingResultItem::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline double BacktestingResultSave2DBRequery_BacktestingResultItem::money() const {
  return money_;
}
inline void BacktestingResultSave2DBRequery_BacktestingResultItem::set_money(double value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// BacktestingResultSave2DBRequery

// required string table_name = 1;
inline bool BacktestingResultSave2DBRequery::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BacktestingResultSave2DBRequery::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BacktestingResultSave2DBRequery::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BacktestingResultSave2DBRequery::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& BacktestingResultSave2DBRequery::table_name() const {
  return *table_name_;
}
inline void BacktestingResultSave2DBRequery::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void BacktestingResultSave2DBRequery::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void BacktestingResultSave2DBRequery::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BacktestingResultSave2DBRequery::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* BacktestingResultSave2DBRequery::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BacktestingResultSave2DBRequery::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 total = 2;
inline bool BacktestingResultSave2DBRequery::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BacktestingResultSave2DBRequery::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BacktestingResultSave2DBRequery::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BacktestingResultSave2DBRequery::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 BacktestingResultSave2DBRequery::total() const {
  return total_;
}
inline void BacktestingResultSave2DBRequery::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// required int32 chart = 3;
inline bool BacktestingResultSave2DBRequery::has_chart() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BacktestingResultSave2DBRequery::set_has_chart() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BacktestingResultSave2DBRequery::clear_has_chart() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BacktestingResultSave2DBRequery::clear_chart() {
  chart_ = 0;
  clear_has_chart();
}
inline ::google::protobuf::int32 BacktestingResultSave2DBRequery::chart() const {
  return chart_;
}
inline void BacktestingResultSave2DBRequery::set_chart(::google::protobuf::int32 value) {
  set_has_chart();
  chart_ = value;
}

// repeated .ctp.cp.BacktestingResultSave2DBRequery.BacktestingResultItem data = 4;
inline int BacktestingResultSave2DBRequery::data_size() const {
  return data_.size();
}
inline void BacktestingResultSave2DBRequery::clear_data() {
  data_.Clear();
}
inline const ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem& BacktestingResultSave2DBRequery::data(int index) const {
  return data_.Get(index);
}
inline ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem* BacktestingResultSave2DBRequery::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem* BacktestingResultSave2DBRequery::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem >&
BacktestingResultSave2DBRequery::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::ctp::cp::BacktestingResultSave2DBRequery_BacktestingResultItem >*
BacktestingResultSave2DBRequery::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// BacktestingResultSave2DBResponse

// required string table_name = 1;
inline bool BacktestingResultSave2DBResponse::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BacktestingResultSave2DBResponse::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BacktestingResultSave2DBResponse::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BacktestingResultSave2DBResponse::clear_table_name() {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    table_name_->clear();
  }
  clear_has_table_name();
}
inline const ::std::string& BacktestingResultSave2DBResponse::table_name() const {
  return *table_name_;
}
inline void BacktestingResultSave2DBResponse::set_table_name(const ::std::string& value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void BacktestingResultSave2DBResponse::set_table_name(const char* value) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(value);
}
inline void BacktestingResultSave2DBResponse::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  table_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BacktestingResultSave2DBResponse::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    table_name_ = new ::std::string;
  }
  return table_name_;
}
inline ::std::string* BacktestingResultSave2DBResponse::release_table_name() {
  clear_has_table_name();
  if (table_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_name_;
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BacktestingResultSave2DBResponse::set_allocated_table_name(::std::string* table_name) {
  if (table_name_ != &::google::protobuf::internal::kEmptyString) {
    delete table_name_;
  }
  if (table_name) {
    set_has_table_name();
    table_name_ = table_name;
  } else {
    clear_has_table_name();
    table_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 progress = 2;
inline bool BacktestingResultSave2DBResponse::has_progress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BacktestingResultSave2DBResponse::set_has_progress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BacktestingResultSave2DBResponse::clear_has_progress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BacktestingResultSave2DBResponse::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline ::google::protobuf::int32 BacktestingResultSave2DBResponse::progress() const {
  return progress_;
}
inline void BacktestingResultSave2DBResponse::set_progress(::google::protobuf::int32 value) {
  set_has_progress();
  progress_ = value;
}

// -------------------------------------------------------------------

// test1

// required string s = 1;
inline bool test1::has_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void test1::set_has_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void test1::clear_has_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void test1::clear_s() {
  if (s_ != &::google::protobuf::internal::kEmptyString) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& test1::s() const {
  return *s_;
}
inline void test1::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(value);
}
inline void test1::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(value);
}
inline void test1::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* test1::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  return s_;
}
inline ::std::string* test1::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void test1::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::kEmptyString) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// test2

// required string s2 = 1;
inline bool test2::has_s2() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void test2::set_has_s2() {
  _has_bits_[0] |= 0x00000001u;
}
inline void test2::clear_has_s2() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void test2::clear_s2() {
  if (s2_ != &::google::protobuf::internal::kEmptyString) {
    s2_->clear();
  }
  clear_has_s2();
}
inline const ::std::string& test2::s2() const {
  return *s2_;
}
inline void test2::set_s2(const ::std::string& value) {
  set_has_s2();
  if (s2_ == &::google::protobuf::internal::kEmptyString) {
    s2_ = new ::std::string;
  }
  s2_->assign(value);
}
inline void test2::set_s2(const char* value) {
  set_has_s2();
  if (s2_ == &::google::protobuf::internal::kEmptyString) {
    s2_ = new ::std::string;
  }
  s2_->assign(value);
}
inline void test2::set_s2(const char* value, size_t size) {
  set_has_s2();
  if (s2_ == &::google::protobuf::internal::kEmptyString) {
    s2_ = new ::std::string;
  }
  s2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* test2::mutable_s2() {
  set_has_s2();
  if (s2_ == &::google::protobuf::internal::kEmptyString) {
    s2_ = new ::std::string;
  }
  return s2_;
}
inline ::std::string* test2::release_s2() {
  clear_has_s2();
  if (s2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = s2_;
    s2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void test2::set_allocated_s2(::std::string* s2) {
  if (s2_ != &::google::protobuf::internal::kEmptyString) {
    delete s2_;
  }
  if (s2) {
    set_has_s2();
    s2_ = s2;
  } else {
    clear_has_s2();
    s2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ctp.cp.test1 t2 = 2;
inline bool test2::has_t2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void test2::set_has_t2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void test2::clear_has_t2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void test2::clear_t2() {
  if (t2_ != NULL) t2_->::ctp::cp::test1::Clear();
  clear_has_t2();
}
inline const ::ctp::cp::test1& test2::t2() const {
  return t2_ != NULL ? *t2_ : *default_instance_->t2_;
}
inline ::ctp::cp::test1* test2::mutable_t2() {
  set_has_t2();
  if (t2_ == NULL) t2_ = new ::ctp::cp::test1;
  return t2_;
}
inline ::ctp::cp::test1* test2::release_t2() {
  clear_has_t2();
  ::ctp::cp::test1* temp = t2_;
  t2_ = NULL;
  return temp;
}
inline void test2::set_allocated_t2(::ctp::cp::test1* t2) {
  delete t2_;
  t2_ = t2;
  if (t2) {
    set_has_t2();
  } else {
    clear_has_t2();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cp
}  // namespace ctp

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cp_5fcomunication_2eproto__INCLUDED
